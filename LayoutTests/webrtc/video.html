<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Testing basic video exchange from offerer to receiver</title>
        <script src="../resources/testharness.js"></script>
        <script src="../resources/testharnessreport.js"></script>
    </head>
    <body>
        <video id="video" autoplay=""></video>
        <canvas id="canvas" width="640" height="480"></canvas>
        <script src ="routines.js"></script>
        <script>
video = document.getElementById("video");
canvas = document.getElementById("canvas");

function testImage()
{
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    canvas.getContext('2d').drawImage(video, 0, 0, canvas.width, canvas.height);

    imageData = canvas.getContext('2d').getImageData(10, 325, 250, 1);
    data = imageData.data;

    var index = 20;
    assert_true(data[index] < 100);
    assert_true(data[index + 1] < 100);
    assert_true(data[index + 2] < 100);

    index = 80;
    assert_true(data[index] > 200);
    assert_true(data[index + 1] > 200);
    assert_true(data[index + 2] > 200);

    index += 80;
    assert_true(data[index] > 200);
    assert_true(data[index + 1] > 200);
    assert_true(data[index + 2] < 100);
}

var pc1, pc2;
promise_test(async (test) => {
    if (window.testRunner)
        testRunner.setUserMediaPermission(true);

    const localStream = await navigator.mediaDevices.getUserMedia({video: {advanced: [{width:{min:640}}, {height:{min:480} } ]}});
    if (window.internals)
        assert_true(internals.pageMediaState().includes('HasActiveVideoCaptureDevice'), "Unexpected HasActiveVideoCaptureDevice");
    const stream = await new Promise((resolve, reject) => {
        createConnections((firstConnection) => {
            pc1 = firstConnection;
            firstConnection.addTrack(localStream.getVideoTracks()[0], localStream);
        }, (secondConnection) => {
            pc2 = secondConnection;
            secondConnection.ontrack = (trackEvent) => {
                assert_true(trackEvent.track instanceof MediaStreamTrack);
                assert_true(trackEvent.receiver instanceof RTCRtpReceiver);
                assert_true(Array.isArray(trackEvent.streams), "Array.isArray() should return true");
                assert_true(Object.isFrozen(trackEvent.streams), "Object.isFrozen() should return true");
                assert_equals(trackEvent.track.id, localStream.getVideoTracks()[0].id);
                assert_equals(trackEvent.track, trackEvent.streams[0].getVideoTracks()[0]);
                resolve(trackEvent.streams[0]);
            };
        });
        setTimeout(() => reject("Test timed out"), 5000);
    });

    video.srcObject = stream;
    await video.play();

    testImage();
}, "Basic video exchange");

async function getInboundRTPStatsNumberOfDecodedFrames(connection)
{
    var report = await connection.getStats();
    var framesDecoded;
    report.forEach((statItem) => {
        if (statItem.type === "inbound-rtp")
            framesDecoded = statItem.framesDecoded;
    });
    return framesDecoded;
}

async function testFrameDecodedIncreased(connection, count, previousFramesNumber)
{
    if (previousFramesNumber === undefined) {
        let number = await getInboundRTPStatsNumberOfDecodedFrames(connection);
        await waitFor(1000);
        return testFrameDecodedIncreased(connection, 0, number);
    }

    var number = await getInboundRTPStatsNumberOfDecodedFrames(connection);
    if (previousFramesNumber && number > previousFramesNumber)
        return;

    if (count >= 20)
        return Promise.reject("test increasing frame encoded timed out");

    await waitFor(1000);
    return testFrameDecodedIncreased(connection, ++count, previousFramesNumber);
}

async function testFrameDecodedDidNotIncreased(connection, count, previousFramesNumber)
{
    if (previousFramesNumber === undefined) {
        let number = await getInboundRTPStatsNumberOfDecodedFrames(connection);
        await waitFor(100);
        return testFrameDecodedDidNotIncreased(connection, 0, number);
    }

    var number = await getInboundRTPStatsNumberOfDecodedFrames(connection);
    if (previousFramesNumber && number == previousFramesNumber)
        return;

    if (count >= 20)
        return Promise.reject("test increasing frame encoded timed out");

    await waitFor(100);
    return testFrameDecodedIncreased(connection, ++count, number);
}

promise_test(async (test) => {
   let p = pc1.getSenders()[0].getParameters();
   p.encodings[0].active = false;
   await pc1.getSenders()[0].setParameters(p);

   await testFrameDecodedDidNotIncreased(pc2);
}, "Call setParameters to disable sending a given encoding");

promise_test(async (test) => {
   let p = pc1.getSenders()[0].getParameters();
   p.encodings[0].active = true;
   await pc1.getSenders()[0].setParameters(p);

   await testFrameDecodedIncreased(pc2);
}, "Call setParameters to reenable sending a given encoding");
        </script>
    </body>
</html>
