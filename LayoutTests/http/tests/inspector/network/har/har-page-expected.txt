HAR Page Test.


== Running test suite: HAR.Page
-- Running test case: HAR.Basic.Page
{
  "log": {
    "version": "1.2",
    "creator": {
      "name": "WebKit Web Inspector",
      "version": "<filtered>"
    },
    "pages": [
      {
        "startedDateTime": "<filtered>",
        "id": "page_0",
        "title": "http://127.0.0.1:8000/inspector/network/har/har-page.html",
        "pageTimings": {
          "onContentLoad": "<filtered>",
          "onLoad": "<filtered>"
        }
      }
    ],
    "entries": [
      {
        "pageref": "page_0",
        "startedDateTime": "<filtered>",
        "time": "<filtered>",
        "request": {
          "method": "GET",
          "url": "http://127.0.0.1:8000/inspector/network/har/har-page.html",
          "httpVersion": "HTTP/1.1",
          "cookies": [],
          "headers": "<filtered>",
          "queryString": [],
          "headersSize": "<filtered>",
          "bodySize": "<filtered>"
        },
        "response": {
          "status": 200,
          "statusText": "OK",
          "httpVersion": "HTTP/1.1",
          "cookies": [],
          "headers": "<filtered>",
          "content": {
            "size": 2658,
            "compression": 0,
            "mimeType": "text/html",
            "text": "<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"utf-8\">\n<script src=\"../../resources/inspector-test.js\"></script>\n<script>\nfunction test()\n{\n    function HARJSONFilter(key, value) {\n        // Filter out the creator.version / browser.version but leave a top level version.\n        if ((key === \"creator\" || key === \"browser\") && value.version) {\n            value.version = \"<filtered>\";\n            return value;\n        }\n\n        // Headers include dynamic data.\n        if (key === \"headers\")\n            return \"<filtered>\";\n\n        // Dates would change between test runs.\n        if (key.endsWith(\"DateTime\"))\n            return \"<filtered>\";\n\n        // Size data may or may not be available, but could change based on headers.\n        if (key.endsWith(\"Size\"))\n            return \"<filtered>\";\n\n        // Connection identifier could be different.\n        if (key === \"connection\")\n            return \"<filtered>\";\n\n        // Cache may or may not have been used.\n        if (key === \"_fetchType\")\n            return \"<filtered>\";\n\n        // Since cache may or may not be used, timing data may be variable.\n        // NOTE: SSL should always be -1 for this test case.\n        if (key === \"time\")\n            return \"<filtered>\";\n        if (key === \"timings\") {\n            value.blocked = \"<filtered>\";\n            value.dns = \"<filtered>\";\n            value.connect = \"<filtered>\";\n            value.send = \"<filtered>\";\n            value.wait = \"<filtered>\";\n            value.receive = \"<filtered>\";\n        }\n\n        // PageTimings can be variable.\n        if (key === \"onContentLoad\" || key === \"onLoad\")\n            return \"<filtered>\";\n\n        return value;\n    }\n\n    let suite = InspectorTest.createAsyncSuite(\"HAR.Page\");\n\n    suite.addTestCase({\n        name: \"HAR.Basic.Page\",\n        description: \"Should be able to generate a HAR with all of this test page's resources.\",\n        async test() {\n            InspectorTest.reloadPage({ignoreCache: true});\n            await InspectorTest.awaitEvent(\"LoadComplete\");\n\n            let resources = [];\n            resources.push(WI.frameResourceManager.mainFrame.mainResource);\n            for (let resource of WI.frameResourceManager.mainFrame.resourceCollection.items)\n                resources.push(resource);\n\n            let har = await WI.HARBuilder.buildArchive(resources);\n            InspectorTest.json(har, HARJSONFilter);\n        }\n    });\n\n    suite.runTestCasesAndFinish();\n}\n</script>\n</head>\n<body onload=\"runTest()\">\n<p>HAR Page Test.</p>\n<script>\nwindow.addEventListener(\"load\", () => {\n    TestPage.dispatchEventToFrontend(\"LoadComplete\");\n});\n</script>\n</body>\n</html>\n"
          },
          "redirectURL": "",
          "headersSize": "<filtered>",
          "bodySize": "<filtered>",
          "_transferSize": "<filtered>"
        },
        "cache": {},
        "timings": {
          "blocked": "<filtered>",
          "dns": "<filtered>",
          "connect": "<filtered>",
          "ssl": -1,
          "send": "<filtered>",
          "wait": "<filtered>",
          "receive": "<filtered>"
        },
        "serverIPAddress": "127.0.0.1",
        "connection": "<filtered>",
        "_fetchType": "<filtered>"
      },
      {
        "pageref": "page_0",
        "startedDateTime": "<filtered>",
        "time": "<filtered>",
        "request": {
          "method": "GET",
          "url": "http://127.0.0.1:8000/inspector/resources/inspector-test.js",
          "httpVersion": "",
          "cookies": [],
          "headers": "<filtered>",
          "queryString": [],
          "headersSize": "<filtered>",
          "bodySize": "<filtered>"
        },
        "response": {
          "status": 200,
          "statusText": "OK",
          "httpVersion": "",
          "cookies": [],
          "headers": "<filtered>",
          "content": {
            "size": 0,
            "compression": 0,
            "mimeType": "application/x-javascript",
            "text": "/*\n * Copyright (C) 2013-2015 Apple Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n// This namespace is injected into every test page. Its functions are invoked by\n// InspectorTest methods on the inspector page via a TestHarness subclass.\nTestPage = {};\nTestPage._initializers = [];\n\n// Helper scripts like `debugger-test.js` must register their initialization\n// function with this method so it will be marshalled to the inspector page.\nTestPage.registerInitializer = function(initializer)\n{\n    if (typeof initializer === \"function\")\n        this._initializers.push(initializer.toString());\n}\n\n// This function is called by the test document's body onload handler.\n\n// It initializes the inspector and loads any `*-test.js` helper scripts\n// into the inspector page context.\nfunction runTest()\n{\n    // Don't try to use testRunner if running through the browser.\n    if (!window.testRunner)\n        return;\n\n    // Set up the test page before the load event fires.\n    testRunner.dumpAsText();\n    testRunner.waitUntilDone();\n\n    window.internals.setInspectorIsUnderTest(true);\n    testRunner.showWebInspector();\n\n    let testFunction = window.test;\n    if (typeof testFunction !== \"function\") {\n        alert(\"Failed to send test() because it is not a function.\");\n        testRunner.notifyDone();\n    }\n\n    function runInitializationMethodsInFrontend(initializersArray)\n    {\n        InspectorTest.testPageDidLoad();\n\n        // If the test page reloaded but we started running the test in a previous\n        // navigation, then don't initialize the inspector frontend again.\n        if (InspectorTest.didInjectTestCode)\n            return;\n\n        for (let initializer of initializersArray) {\n            try {\n                initializer();\n            } catch (e) {\n                console.error(\"Exception in test initialization: \" + e, e.stack || \"(no stack trace)\");\n                InspectorTest.completeTest();\n            }\n        }\n    }\n\n    function runTestMethodInFrontend(testFunction)\n    {\n        if (InspectorTest.didInjectTestCode)\n            return;\n\n        InspectorTest.didInjectTestCode = true;\n\n        try {\n            testFunction();\n        } catch (e) {\n            // Using this instead of window.onerror will preserve the stack trace.\n            e.code = testFunction.toString();\n            InspectorTest.reportUncaughtException(e);\n        }\n    }\n\n    let initializationCodeString = `(${runInitializationMethodsInFrontend.toString()})([${TestPage._initializers}]);`;\n    let testFunctionCodeString = `(${runTestMethodInFrontend.toString()})(${testFunction.toString()});`;\n\n    testRunner.evaluateInWebInspector(initializationCodeString);\n    testRunner.evaluateInWebInspector(testFunctionCodeString);\n}\n\nfunction runTestHTTPS()\n{\n    if (window.testRunner) {\n        testRunner.dumpAsText();\n        testRunner.waitUntilDone();\n    }\n\n    let url = new URL(document.URL);\n    if (url.protocol !== \"https:\") {\n        url.protocol = \"https:\";\n        url.port = \"8443\";\n        window.location.href = url.toString();\n        return;\n    }\n\n    runTest();\n}\n\nTestPage.completeTest = function()\n{\n    // Don't try to use testRunner if running through the browser.\n    if (!window.testRunner)\n        return;\n\n    // Close inspector asynchrously in case we want to test tear-down behavior.\n    setTimeout(() => {\n        testRunner.closeWebInspector();\n        setTimeout(() => { testRunner.notifyDone(); }, 0);\n    }, 0);\n}\n\n// Logs message to unbuffered process stdout, avoiding timeouts.\n// only be used to debug tests and not to produce normal test output.\nTestPage.debugLog = function(message)\n{\n    window.alert(message);\n}\n\n// Add and clear test output from the results window.\nTestPage.addResult = function(text)\n{\n    // For early errors triggered when loading the test page, write to stderr.\n    if (!document.body) {\n        this.debugLog(text);\n        this.completeTest();\n    }\n\n    if (!this._resultElement) {\n        this._resultElement = document.createElement(\"pre\");\n        this._resultElement.id = \"output\";\n        document.body.appendChild(this._resultElement);\n    }\n\n    this._resultElement.append(text, document.createElement(\"br\"));\n}\n\nTestPage.log = TestPage.addResult;\n\nTestPage.dispatchEventToFrontend = function(eventName, data)\n{\n    let dispatchEventCodeString = `InspectorTest.dispatchEventToListeners(${JSON.stringify(eventName)}, ${JSON.stringify(data)});`;\n    testRunner.evaluateInWebInspector(dispatchEventCodeString);\n};\n\nTestPage.allowUncaughtExceptions = false;\nTestPage.needToSanitizeUncaughtExceptionURLs = false;\n\nTestPage.reportUncaughtException = function(message, url, lineNumber)\n{\n    if (TestPage.needToSanitizeUncaughtExceptionURLs) {\n        if (typeof url === \"string\") {\n            let lastSlash = url.lastIndexOf(\"/\");\n            let lastBackSlash = url.lastIndexOf(\"\\\\\");\n            let lastPathSeparator = Math.max(lastSlash, lastBackSlash);\n            if (lastPathSeparator > 0)\n                url = url.substr(lastPathSeparator + 1);\n        }\n    }\n\n    let result = `Uncaught exception in test page: ${message} [${url}:${lineNumber}]`;\n    TestPage.addResult(result);\n\n    if (!TestPage.allowUncaughtExceptions)\n        TestPage.completeTest();\n}\n\n// Catch syntax errors, type errors, and other exceptions. Run this before loading other files.\nwindow.onerror = TestPage.reportUncaughtException.bind(TestPage);\n"
          },
          "redirectURL": "",
          "headersSize": "<filtered>",
          "bodySize": "<filtered>",
          "_transferSize": "<filtered>"
        },
        "cache": {},
        "timings": {
          "blocked": "<filtered>",
          "dns": "<filtered>",
          "connect": "<filtered>",
          "ssl": -1,
          "send": "<filtered>",
          "wait": "<filtered>",
          "receive": "<filtered>"
        },
        "_fetchType": "<filtered>"
      }
    ]
  }
}

