2013-10-13  Mark Lam  <mark.lam@apple.com>

        Transition misc cti_op_* JITStubs to JIT operations.
        https://bugs.webkit.org/show_bug.cgi?id=122645.

        Reviewed by Michael Saboff.

        Stubs converted:
            cti_op_check_has_instance
            cti_op_create_arguments
            cti_op_del_by_id
            cti_op_instanceof
            cti_to_object
            cti_op_push_activation
            cti_op_get_pnames
            cti_op_load_varargs

        * dfg/DFGOperations.cpp:
        * dfg/DFGOperations.h:
        * jit/CCallHelpers.h:
        (JSC::CCallHelpers::setupArgumentsWithExecState):
        * jit/JIT.h:
        (JSC::JIT::emitStoreCell):
        * jit/JITCall.cpp:
        (JSC::JIT::compileLoadVarargs):
        * jit/JITCall32_64.cpp:
        (JSC::JIT::compileLoadVarargs):
        * jit/JITInlines.h:
        (JSC::JIT::callOperation):
        * jit/JITOpcodes.cpp:
        (JSC::JIT::emit_op_get_pnames):
        (JSC::JIT::emit_op_create_activation):
        (JSC::JIT::emit_op_create_arguments):
        (JSC::JIT::emitSlow_op_check_has_instance):
        (JSC::JIT::emitSlow_op_instanceof):
        (JSC::JIT::emitSlow_op_get_argument_by_val):
        * jit/JITOpcodes32_64.cpp:
        (JSC::JIT::emitSlow_op_check_has_instance):
        (JSC::JIT::emitSlow_op_instanceof):
        (JSC::JIT::emit_op_get_pnames):
        (JSC::JIT::emit_op_create_activation):
        (JSC::JIT::emit_op_create_arguments):
        (JSC::JIT::emitSlow_op_get_argument_by_val):
        * jit/JITOperations.cpp:
        * jit/JITOperations.h:
        * jit/JITPropertyAccess.cpp:
        (JSC::JIT::emit_op_del_by_id):
        * jit/JITPropertyAccess32_64.cpp:
        (JSC::JIT::emit_op_del_by_id):
        * jit/JITStubs.cpp:
        * jit/JITStubs.h:

2013-10-13  Filip Pizlo  <fpizlo@apple.com>

        FTL OSR exit should perform zero extension on values smaller than 64-bit
        https://bugs.webkit.org/show_bug.cgi?id=122688

        Reviewed by Gavin Barraclough.
        
        In the DFG we usually make the simplistic assumption that a 32-bit value in a 64-bit
        register will have zeros on the high bits.  In the few cases where the high bits are
        non-zero, the DFG sort of tells us this explicitly.

        But when working with llvm.webkit.stackmap, it doesn't work that way.  Consider we might
        emit LLVM IR like:

            %2 = trunc i64 %1 to i32
            stuff %2
            call @llvm.webkit.stackmap(...., %2)

        LLVM may never actually emit a truncation instruction of any kind.  And that's great - in
        many cases it won't be needed, like if 'stuff %2' is a 32-bit op that ignores the high
        bits anyway.  Hence LLVM may tell us that %2 is in the register that still had the value
        from before truncation, and that register may have garbage in the high bits.

        This means that on our end, if we want a 32-bit value and we want that value to be
        zero-extended, we should zero-extend it ourselves.  This is pretty easy and should be
        cheap, so we should just do it and not make it a requirement that LLVM does it on its
        end.
        
        This makes all tests pass with JSC_ftlOSRExitUsesStackmap=true.

        * ftl/FTLOSRExitCompiler.cpp:
        (JSC::FTL::compileStubWithOSRExitStackmap):
        * ftl/FTLValueFormat.cpp:
        (JSC::FTL::reboxAccordingToFormat):

== Rolled over to ChangeLog-2013-10-13 ==
