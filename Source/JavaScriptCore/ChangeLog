2015-12-01  Youenn Fablet  <youenn.fablet@crf.canon.fr>

        [Streams API] Remove use of @catch for exposed promises
        https://bugs.webkit.org/show_bug.cgi?id=151625

        Reviewed by Darin Adler.

        * runtime/JSPromisePrototype.cpp:
        (JSC::JSPromisePrototype::addOwnInternalSlots): Removing @catch from the prototype as it is not safe.

2015-11-30  Filip Pizlo  <fpizlo@apple.com>

        B3::ValueRep::Any should translate into a Arg::ColdUse role in Air
        https://bugs.webkit.org/show_bug.cgi?id=151174

        Reviewed by Geoffrey Garen and Benjamin Poulain.

        This teaches the register allocator that it should pick spills based on whichever tmp has the
        highest score:

            score(tmp) = degree(tmp) / sum(for each use of tmp, block->frequency)

        In other words, the numerator is the number of edges in the inteference graph and the denominator
        is an estimate of the dynamic number of uses.

        This also extends Arg::Role to know that there is such a thing as ColdUse, i.e. a Use that
        doesn't count as such for the above formula. Because LateUse is always used in contexts where we
        want it to be Cold, I've defined LateUse to imply ColdUse.

        This gets rid of all spilling inside the hot loop in Kraken/imaging-gaussian-blur. But more
        importantly, it makes our register allocator use a well-known heuristic based on reusable
        building blocks like the new Air::UseCounts. Even if the heuristic is slightly wrong, the right
        heuristic probably uses the same building blocks.

        * JavaScriptCore.xcodeproj/project.pbxproj:
        * b3/B3StackmapSpecial.cpp:
        (JSC::B3::StackmapSpecial::forEachArgImpl):
        * b3/B3ValueRep.h:
        * b3/air/AirArg.cpp:
        (WTF::printInternal):
        * b3/air/AirArg.h:
        (JSC::B3::Air::Arg::isAnyUse):
        (JSC::B3::Air::Arg::isColdUse):
        (JSC::B3::Air::Arg::isWarmUse):
        (JSC::B3::Air::Arg::isEarlyUse):
        (JSC::B3::Air::Arg::isDef):
        * b3/air/AirIteratedRegisterCoalescing.cpp:
        (JSC::B3::Air::iteratedRegisterCoalescing):
        (JSC::B3::Air::IteratedRegisterCoalescingAllocator::IteratedRegisterCoalescingAllocator): Deleted.
        (JSC::B3::Air::IteratedRegisterCoalescingAllocator::allocatedReg): Deleted.
        (JSC::B3::Air::IteratedRegisterCoalescingAllocator::tmpArraySize): Deleted.
        (JSC::B3::Air::IteratedRegisterCoalescingAllocator::initializeDegrees): Deleted.
        (JSC::B3::Air::IteratedRegisterCoalescingAllocator::build): Deleted.
        (JSC::B3::Air::IteratedRegisterCoalescingAllocator::selectSpill): Deleted.
        (JSC::B3::Air::isUselessMoveInst): Deleted.
        (JSC::B3::Air::assignRegisterToTmpInProgram): Deleted.
        (JSC::B3::Air::addSpillAndFillToProgram): Deleted.
        (JSC::B3::Air::iteratedRegisterCoalescingOnType): Deleted.
        * b3/air/AirLiveness.h:
        * b3/air/AirSpillEverything.cpp:
        (JSC::B3::Air::spillEverything):
        * b3/air/AirUseCounts.h: Added.
        (JSC::B3::Air::UseCounts::Counts::dump):
        (JSC::B3::Air::UseCounts::UseCounts):
        (JSC::B3::Air::UseCounts::operator[]):
        (JSC::B3::Air::UseCounts::dump):
        * runtime/Options.h:

2015-11-30  Csaba Osztrogon√°c  <ossy@webkit.org>

        Fix the !ENABLE(DFG_JIT) build after r192699
        https://bugs.webkit.org/show_bug.cgi?id=151616

        Reviewed by Darin Adler.

        * assembler/MacroAssembler.h:

2015-11-30  Yusuke Suzuki  <utatane.tea@gmail.com>

        Object::{freeze, seal} perform preventExtensionsTransition twice
        https://bugs.webkit.org/show_bug.cgi?id=151606

        Reviewed by Darin Adler.

        In Structure::{freezeTransition, sealTransition}, we perform preventExtensionsTransition.
        So it is unnecessary to perform preventExtensionsTransition before executing Structure::{freezeTransition, sealTransition}.

        * runtime/JSObject.cpp:
        (JSC::JSObject::seal):
        (JSC::JSObject::freeze):
        (JSC::JSObject::preventExtensions):
        * tests/stress/freeze-and-seal-should-prevent-extensions.js: Added.
        (shouldBe):
        (shouldThrow):

2015-11-30  Benjamin Poulain  <bpoulain@apple.com>

        [JSC] Add Sqrt to B3
        https://bugs.webkit.org/show_bug.cgi?id=151692

        Reviewed by Geoffrey Garen.

        * assembler/MacroAssemblerX86Common.h:
        (JSC::MacroAssemblerX86Common::sqrtDouble):
        * assembler/X86Assembler.h:
        (JSC::X86Assembler::sqrtsd_mr):
        * b3/B3LowerToAir.cpp:
        (JSC::B3::Air::LowerToAir::lower):
        * b3/B3Opcode.cpp:
        (WTF::printInternal):
        * b3/B3Opcode.h:
        * b3/B3Validate.cpp:
        * b3/B3Value.cpp:
        (JSC::B3::Value::effects):
        (JSC::B3::Value::key):
        (JSC::B3::Value::typeFor):
        * b3/air/AirOpcode.opcodes:
        * b3/testb3.cpp:
        (JSC::B3::testSqrtArg):
        (JSC::B3::testSqrtImm):
        (JSC::B3::testSqrtMem):
        (JSC::B3::run):
        * ftl/FTLB3Output.h:
        (JSC::FTL::Output::doubleSqrt):

2015-11-30  Filip Pizlo  <fpizlo@apple.com>

        FTL lazy slow paths should work with B3
        https://bugs.webkit.org/show_bug.cgi?id=151667

        Reviewed by Geoffrey Garen.

        This adds all of the glue necessary to make FTL::LazySlowPath work with B3. The B3 approach
        allows us to put all of the code in FTL::LowerDFGToLLVM, instead of having supporting data
        structures on the side and a bunch of complex code in FTLCompile.cpp.

        * b3/B3CheckSpecial.cpp:
        (JSC::B3::CheckSpecial::generate):
        * b3/B3LowerToAir.cpp:
        (JSC::B3::Air::LowerToAir::run):
        * b3/B3PatchpointSpecial.cpp:
        (JSC::B3::PatchpointSpecial::generate):
        * b3/B3StackmapValue.h:
        * ftl/FTLJSTailCall.cpp:
        (JSC::FTL::DFG::recoveryFor):
        (JSC::FTL::JSTailCall::emit):
        * ftl/FTLLazySlowPath.cpp:
        (JSC::FTL::LazySlowPath::LazySlowPath):
        (JSC::FTL::LazySlowPath::generate):
        * ftl/FTLLazySlowPath.h:
        (JSC::FTL::LazySlowPath::createGenerator):
        (JSC::FTL::LazySlowPath::patchableJump):
        (JSC::FTL::LazySlowPath::done):
        (JSC::FTL::LazySlowPath::patchpoint):
        (JSC::FTL::LazySlowPath::usedRegisters):
        (JSC::FTL::LazySlowPath::callSiteIndex):
        (JSC::FTL::LazySlowPath::stub):
        * ftl/FTLLocation.cpp:
        (JSC::FTL::Location::forValueRep):
        (JSC::FTL::Location::forStackmaps):
        (JSC::FTL::Location::dump):
        (JSC::FTL::Location::isGPR):
        (JSC::FTL::Location::gpr):
        (JSC::FTL::Location::isFPR):
        (JSC::FTL::Location::fpr):
        (JSC::FTL::Location::restoreInto):
        * ftl/FTLLocation.h:
        (JSC::FTL::Location::Location):
        (JSC::FTL::Location::forRegister):
        (JSC::FTL::Location::forIndirect):
        (JSC::FTL::Location::forConstant):
        (JSC::FTL::Location::kind):
        (JSC::FTL::Location::hasReg):
        (JSC::FTL::Location::reg):
        (JSC::FTL::Location::hasOffset):
        (JSC::FTL::Location::offset):
        (JSC::FTL::Location::hash):
        (JSC::FTL::Location::hasDwarfRegNum): Deleted.
        (JSC::FTL::Location::dwarfRegNum): Deleted.
        (JSC::FTL::Location::hasDwarfReg): Deleted.
        (JSC::FTL::Location::dwarfReg): Deleted.
        * ftl/FTLLowerDFGToLLVM.cpp:
        (JSC::FTL::DFG::LowerDFGToLLVM::LowerDFGToLLVM):
        (JSC::FTL::DFG::LowerDFGToLLVM::lazySlowPath):
        * jit/RegisterSet.cpp:
        (JSC::RegisterSet::stubUnavailableRegisters):
        (JSC::RegisterSet::macroScratchRegisters):
        (JSC::RegisterSet::calleeSaveRegisters):
        * jit/RegisterSet.h:

2015-11-30  Geoffrey Garen  <ggaren@apple.com>

        Use a better RNG for Math.random()
        https://bugs.webkit.org/show_bug.cgi?id=151641

        Reviewed by Anders Carlsson.

        Updated for interface change.

        * runtime/JSGlobalObject.cpp:
        (JSC::JSGlobalObject::setInputCursor):

2015-11-30  Benjamin Poulain  <bpoulain@apple.com>

        [JSC] Speed up Air Liveness Analysis on Tmps
        https://bugs.webkit.org/show_bug.cgi?id=151556

        Reviewed by Filip Pizlo.

        Liveness Analysis scales poorly on large graphs like the ones
        generated by testComplex().
        This patch introduces a faster of Liveness using the continuous indices
        of values instead of the values themselves.

        There are two main areas of improvements:
        1) Reduce the cost of doing a LocalCalc over a BasicBlock.
        2) Reduce how many LocalCalc are needed to converge to a solution.

        Most of the costs of LocalCalc are from HashSet manipulations.
        The HashSet operations are O(1) but the constant is large enough
        to be a problem.

        I used a similar trick as the Register Allocator to remove hashing
        and collision handling: the absolute value of the Tmp is used as an index
        into a flat array.

        I used Briggs's Sparse Set implementation for the local live information
        at each instruction. It has great properties for doing the local calculation:
        -No memory reallocation.
        -O(1) add() and remove() with a small constant.
        -Strict O(n) iteration.
        -O(1) clear().

        The values Live-At-Head are now stored into a Vector. The Sparse Set
        is used to maintain the Tmp uniqueness.

        When forwarding new liveness at head to the predecessor, I start by removing
        everything that was already in live-at-head. We can assume that any value
        in that list has already been added to the predecessors.
        This leaves us with a small-ish number of Tmps to add to live-at-head
        and to the predecessors.

        The speed up convergence, I used the same trick as DFG's liveness: keep
        a set of dirty blocks to process. In practice, all the blocks without
        back-edges converge quickly, and we only propagate liveness as needed.

        This patch reduces the time taken by "testComplex(64, 384)" by another 5%.

        The remaining things to do for Liveness are:
        -Skip the first block for the fix point (it is often large and doing a local
         calc on it is useless).
        -Find a better Data Structure for live-at-tail (updating the HashSet takes
         > 50% of the total convergence time).

        * JavaScriptCore.xcodeproj/project.pbxproj:
        * b3/air/AirIteratedRegisterCoalescing.cpp:
        (JSC::B3::Air::IteratedRegisterCoalescingAllocator::build):
        (JSC::B3::Air::IteratedRegisterCoalescingAllocator::getAlias):
        (JSC::B3::Air::IteratedRegisterCoalescingAllocator::getAliasWhenSpilling):
        (JSC::B3::Air::IteratedRegisterCoalescingAllocator::allocatedReg):
        (JSC::B3::Air::IteratedRegisterCoalescingAllocator::tmpArraySize):
        (JSC::B3::Air::IteratedRegisterCoalescingAllocator::initializeDegrees):
        (JSC::B3::Air::IteratedRegisterCoalescingAllocator::addEdges):
        (JSC::B3::Air::IteratedRegisterCoalescingAllocator::addEdge):
        (JSC::B3::Air::IteratedRegisterCoalescingAllocator::makeWorkList):
        (JSC::B3::Air::IteratedRegisterCoalescingAllocator::simplify):
        (JSC::B3::Air::IteratedRegisterCoalescingAllocator::forEachAdjacent):
        (JSC::B3::Air::IteratedRegisterCoalescingAllocator::hasBeenSimplified):
        (JSC::B3::Air::IteratedRegisterCoalescingAllocator::decrementDegree):
        (JSC::B3::Air::IteratedRegisterCoalescingAllocator::forEachNodeMoves):
        (JSC::B3::Air::IteratedRegisterCoalescingAllocator::isMoveRelated):
        (JSC::B3::Air::IteratedRegisterCoalescingAllocator::enableMovesOnValue):
        (JSC::B3::Air::IteratedRegisterCoalescingAllocator::precoloredCoalescingHeuristic):
        (JSC::B3::Air::IteratedRegisterCoalescingAllocator::conservativeHeuristic):
        (JSC::B3::Air::IteratedRegisterCoalescingAllocator::addWorkList):
        (JSC::B3::Air::IteratedRegisterCoalescingAllocator::combine):
        (JSC::B3::Air::IteratedRegisterCoalescingAllocator::freezeMoves):
        (JSC::B3::Air::IteratedRegisterCoalescingAllocator::selectSpill):
        (JSC::B3::Air::IteratedRegisterCoalescingAllocator::assignColors):
        (JSC::B3::Air::IteratedRegisterCoalescingAllocator::dumpInterferenceGraphInDot):
        (JSC::B3::Air::iteratedRegisterCoalescingOnType):
        (JSC::B3::Air::iteratedRegisterCoalescing):
        (JSC::B3::Air::AbsoluteTmpHelper<Arg::GP>::absoluteIndex): Deleted.
        (JSC::B3::Air::AbsoluteTmpHelper<Arg::GP>::tmpFromAbsoluteIndex): Deleted.
        (JSC::B3::Air::AbsoluteTmpHelper<Arg::FP>::absoluteIndex): Deleted.
        (JSC::B3::Air::AbsoluteTmpHelper<Arg::FP>::tmpFromAbsoluteIndex): Deleted.
        * b3/air/AirReportUsedRegisters.cpp:
        (JSC::B3::Air::reportUsedRegisters):
        * b3/air/AirTmpInlines.h:
        (JSC::B3::Air::AbsoluteTmpMapper<Arg::GP>::absoluteIndex):
        (JSC::B3::Air::AbsoluteTmpMapper<Arg::GP>::tmpFromAbsoluteIndex):
        (JSC::B3::Air::AbsoluteTmpMapper<Arg::FP>::absoluteIndex):
        (JSC::B3::Air::AbsoluteTmpMapper<Arg::FP>::tmpFromAbsoluteIndex):
        * b3/air/AirLiveness.h: Added.

2015-11-30  Saam barati  <sbarati@apple.com>

        FTL OSR Exits that are exception handlers should not have two different entrances. Instead, we should have two discrete OSR exits that do different things.
        https://bugs.webkit.org/show_bug.cgi?id=151404

        Reviewed by Filip Pizlo.

        * ftl/FTLCompile.cpp:
        (JSC::FTL::mmAllocateDataSection):
        * ftl/FTLExceptionHandlerManager.cpp:
        (JSC::FTL::ExceptionHandlerManager::addNewExit):
        (JSC::FTL::ExceptionHandlerManager::addNewCallOperationExit):
        (JSC::FTL::ExceptionHandlerManager::callOperationExceptionTarget):
        (JSC::FTL::ExceptionHandlerManager::lazySlowPathExceptionTarget):
        (JSC::FTL::ExceptionHandlerManager::callOperationOSRExit):
        (JSC::FTL::ExceptionHandlerManager::getByIdOSRExit): Deleted.
        (JSC::FTL::ExceptionHandlerManager::subOSRExit): Deleted.
        * ftl/FTLExceptionHandlerManager.h:
        * ftl/FTLExitThunkGenerator.cpp:
        (JSC::FTL::ExitThunkGenerator::emitThunk):
        * ftl/FTLOSRExit.cpp:
        (JSC::FTL::OSRExitDescriptor::OSRExitDescriptor):
        (JSC::FTL::OSRExitDescriptor::isExceptionHandler):
        (JSC::FTL::OSRExit::OSRExit):
        (JSC::FTL::OSRExit::spillRegistersToSpillSlot):
        (JSC::FTL::OSRExit::recoverRegistersFromSpillSlot):
        (JSC::FTL::OSRExit::willArriveAtExitFromIndirectExceptionCheck):
        (JSC::FTL::OSRExit::willArriveAtOSRExitFromGenericUnwind):
        (JSC::FTL::OSRExit::willArriveAtOSRExitFromCallOperation):
        (JSC::FTL::OSRExit::needsRegisterRecoveryOnGenericUnwindOSRExitPath):
        (JSC::FTL::OSRExitDescriptor::willArriveAtExitFromIndirectExceptionCheck): Deleted.
        (JSC::FTL::OSRExitDescriptor::mightArriveAtOSRExitFromGenericUnwind): Deleted.
        (JSC::FTL::OSRExitDescriptor::mightArriveAtOSRExitFromCallOperation): Deleted.
        (JSC::FTL::OSRExitDescriptor::needsRegisterRecoveryOnGenericUnwindOSRExitPath): Deleted.
        * ftl/FTLOSRExit.h:
        * ftl/FTLOSRExitCompilationInfo.h:
        (JSC::FTL::OSRExitCompilationInfo::OSRExitCompilationInfo):
        * ftl/FTLOSRExitCompiler.cpp:
        (JSC::FTL::compileFTLOSRExit):

2015-11-30  Mark Lam  <mark.lam@apple.com>

        Refactor the op_add, op_sub, and op_mul snippets to use the SnippetOperand class.
        https://bugs.webkit.org/show_bug.cgi?id=151678

        Reviewed by Geoffrey Garen.

        * dfg/DFGSpeculativeJIT.cpp:
        (JSC::DFG::SpeculativeJIT::compileValueAdd):
        (JSC::DFG::SpeculativeJIT::compileArithSub):
        * ftl/FTLCompile.cpp:
        * jit/JITAddGenerator.cpp:
        (JSC::JITAddGenerator::generateFastPath):
        * jit/JITAddGenerator.h:
        (JSC::JITAddGenerator::JITAddGenerator):
        * jit/JITArithmetic.cpp:
        (JSC::JIT::emit_op_add):
        (JSC::JIT::emit_op_mul):
        (JSC::JIT::emit_op_sub):
        * jit/JITMulGenerator.cpp:
        (JSC::JITMulGenerator::generateFastPath):
        * jit/JITMulGenerator.h:
        (JSC::JITMulGenerator::JITMulGenerator):
        * jit/JITSubGenerator.cpp:
        (JSC::JITSubGenerator::generateFastPath):
        * jit/JITSubGenerator.h:
        (JSC::JITSubGenerator::JITSubGenerator):
        * jit/SnippetOperand.h:
        (JSC::SnippetOperand::isPositiveConstInt32):

2015-11-30  Filip Pizlo  <fpizlo@apple.com>

        B3 stackmaps should support early clobber
        https://bugs.webkit.org/show_bug.cgi?id=151668

        Reviewed by Geoffrey Garen.

        While starting work on FTL lazy slow paths, I realized that we needed some way to say that r11 is
        off limits. Not just that it's clobbered, but that it cannot be used for any input values to a
        stackmap.

        In LLVM we do this by having the AnyRegCC forbid r11.

        In B3, we want something more flexible. In this and other cases, what we really want is an early
        clobber set. B3 already supported a late clobber set for every stackmap value. Late clobber means
        that the act of performing the operation will cause garbage to be written into those registers.
        But here we want: assume that garbage magically appears in those registers in the moment before
        the operation executes. Any registers in that set will be off-limits to the inputs to the
        stackmap. This should be great for other things, like the way the we handle exceptions.

        For the simple r11 issue, what we want is to call the StackmapValue::clobber() method, which now
        means both early and late clobber. It's the weapon of choice whenever you're unsure.

        This adds the early clobber feature, does some minor Inst refactoring to make this less scary,
        and adds a test. The test is simple but it's very comprehensive - for example it tests the
        early-clobber-after-Move special case.

        * b3/B3StackmapSpecial.cpp:
        (JSC::B3::StackmapSpecial::extraClobberedRegs):
        (JSC::B3::StackmapSpecial::extraEarlyClobberedRegs):
        (JSC::B3::StackmapSpecial::forEachArgImpl):
        * b3/B3StackmapSpecial.h:
        * b3/B3StackmapValue.cpp:
        (JSC::B3::StackmapValue::dumpMeta):
        (JSC::B3::StackmapValue::StackmapValue):
        * b3/B3StackmapValue.h:
        * b3/air/AirCCallSpecial.cpp:
        (JSC::B3::Air::CCallSpecial::extraClobberedRegs):
        (JSC::B3::Air::CCallSpecial::extraEarlyClobberedRegs):
        (JSC::B3::Air::CCallSpecial::dumpImpl):
        * b3/air/AirCCallSpecial.h:
        * b3/air/AirInst.h:
        * b3/air/AirInstInlines.h:
        (JSC::B3::Air::Inst::extraClobberedRegs):
        (JSC::B3::Air::Inst::extraEarlyClobberedRegs):
        (JSC::B3::Air::Inst::forEachTmpWithExtraClobberedRegs):
        (JSC::B3::Air::Inst::reportUsedRegisters):
        (JSC::B3::Air::Inst::forEachDefAndExtraClobberedTmp): Deleted.
        * b3/air/AirIteratedRegisterCoalescing.cpp:
        (JSC::B3::Air::IteratedRegisterCoalescingAllocator::IteratedRegisterCoalescingAllocator):
        (JSC::B3::Air::IteratedRegisterCoalescingAllocator::build):
        (JSC::B3::Air::IteratedRegisterCoalescingAllocator::allocate):
        (JSC::B3::Air::IteratedRegisterCoalescingAllocator::initializeDegrees):
        (JSC::B3::Air::IteratedRegisterCoalescingAllocator::addEdges):
        (JSC::B3::Air::IteratedRegisterCoalescingAllocator::addEdge):
        (JSC::B3::Air::iteratedRegisterCoalescingOnType):
        (JSC::B3::Air::iteratedRegisterCoalescing):
        * b3/air/AirSpecial.h:
        * b3/air/AirSpillEverything.cpp:
        (JSC::B3::Air::spillEverything):
        * b3/testb3.cpp:
        (JSC::B3::testSimplePatchpointWithoutOuputClobbersGPArgs):
        (JSC::B3::testSimplePatchpointWithOuputClobbersGPArgs):
        (JSC::B3::testSimplePatchpointWithoutOuputClobbersFPArgs):
        (JSC::B3::testSimplePatchpointWithOuputClobbersFPArgs):
        (JSC::B3::testPatchpointWithEarlyClobber):
        (JSC::B3::testPatchpointCallArg):
        (JSC::B3::run):
        * dfg/DFGCommon.h:

2015-11-30  Mark Lam  <mark.lam@apple.com>

        Snippefy op_div for the baseline JIT.
        https://bugs.webkit.org/show_bug.cgi?id=151607

        Reviewed by Geoffrey Garen.

        * CMakeLists.txt:
        * JavaScriptCore.vcxproj/JavaScriptCore.vcxproj:
        * JavaScriptCore.vcxproj/JavaScriptCore.vcxproj.filters:
        * JavaScriptCore.xcodeproj/project.pbxproj:

        * jit/JIT.h:
        * jit/JITArithmetic.cpp:
        (JSC::JIT::emit_op_div):
        (JSC::JIT::emitSlow_op_div):
        (JSC::JIT::compileBinaryArithOpSlowCase): Deleted.

        * jit/JITArithmetic32_64.cpp:
        (JSC::JIT::emitBinaryDoubleOp):
        (JSC::JIT::emit_op_div): Deleted.
        (JSC::JIT::emitSlow_op_div): Deleted.
        - Removed the 32-bit specific op_div implementation.  The 64-bit version with the
          op_div snippet can now service both 32-bit and 64-bit.
 
        * jit/JITDivGenerator.cpp: Added.
        (JSC::JITDivGenerator::loadOperand):
        (JSC::JITDivGenerator::generateFastPath):
        * jit/JITDivGenerator.h: Added.
        (JSC::JITDivGenerator::JITDivGenerator):
        (JSC::JITDivGenerator::didEmitFastPath):
        (JSC::JITDivGenerator::endJumpList):
        (JSC::JITDivGenerator::slowPathJumpList):
 
        * jit/JITInlines.h:
        (JSC::JIT::getOperandConstantDouble): Added.
 
        * jit/SnippetOperand.h: Added.
        (JSC::SnippetOperand::SnippetOperand):
        (JSC::SnippetOperand::mightBeNumber):
        (JSC::SnippetOperand::definitelyIsNumber):
        (JSC::SnippetOperand::isConst):
        (JSC::SnippetOperand::isConstInt32):
        (JSC::SnippetOperand::isConstDouble):
        (JSC::SnippetOperand::asRawBits):
        (JSC::SnippetOperand::asConstInt32):
        (JSC::SnippetOperand::asConstDouble):
        (JSC::SnippetOperand::setConstInt32):
        (JSC::SnippetOperand::setConstDouble):
        - The SnippetOperand encapsulates operand constness, const type, and profiling
          information.  As a result:
          1. The argument list to the JITDivGenerator constructor is now more concise.
          2. The logic of the JITDivGenerator is now less verbose and easier to express.

        * parser/ResultType.h:
        (JSC::ResultType::isInt32):
        (JSC::ResultType::definitelyIsNumber):
        (JSC::ResultType::definitelyIsString):
        (JSC::ResultType::definitelyIsBoolean):
        (JSC::ResultType::mightBeNumber):
        (JSC::ResultType::isNotNumber):
        - Made these functions const because they were always meant to be const.
          This also allows me to enforce constness in the SnippetOperand.

2015-11-30  Sukolsak Sakshuwong  <sukolsak@gmail.com>

        Fix coding style of Intl code
        https://bugs.webkit.org/show_bug.cgi?id=151491

        Reviewed by Darin Adler.

        This patch does three things:
        1. Rename pointers and references to ExecState from "exec" to "state".
        2. Pass parameters by references instead of pointers if the parameters
           are required.
        3. Remove the word "get" from the names of functions that don't return
           values through out arguments.

        * runtime/IntlCollator.cpp:
        (JSC::IntlCollatorFuncCompare):
        * runtime/IntlCollatorConstructor.cpp:
        (JSC::initializeCollator):
        (JSC::constructIntlCollator):
        (JSC::callIntlCollator):
        (JSC::IntlCollatorConstructor::getOwnPropertySlot):
        (JSC::IntlCollatorConstructorFuncSupportedLocalesOf):
        * runtime/IntlDateTimeFormat.cpp:
        (JSC::IntlDateTimeFormatFuncFormatDateTime):
        * runtime/IntlDateTimeFormatConstructor.cpp:
        (JSC::constructIntlDateTimeFormat):
        (JSC::callIntlDateTimeFormat):
        (JSC::IntlDateTimeFormatConstructor::getOwnPropertySlot):
        (JSC::IntlDateTimeFormatConstructorFuncSupportedLocalesOf):
        * runtime/IntlDateTimeFormatPrototype.cpp:
        (JSC::IntlDateTimeFormatPrototype::getOwnPropertySlot):
        (JSC::IntlDateTimeFormatPrototypeGetterFormat):
        (JSC::IntlDateTimeFormatPrototypeFuncResolvedOptions):
        * runtime/IntlNumberFormat.cpp:
        (JSC::IntlNumberFormatFuncFormatNumber):
        * runtime/IntlNumberFormatConstructor.cpp:
        (JSC::constructIntlNumberFormat):
        (JSC::callIntlNumberFormat):
        (JSC::IntlNumberFormatConstructor::getOwnPropertySlot):
        (JSC::IntlNumberFormatConstructorFuncSupportedLocalesOf):
        * runtime/IntlNumberFormatPrototype.cpp:
        (JSC::IntlNumberFormatPrototype::getOwnPropertySlot):
        (JSC::IntlNumberFormatPrototypeGetterFormat):
        (JSC::IntlNumberFormatPrototypeFuncResolvedOptions):
        * runtime/IntlObject.cpp:
        (JSC::intlBooleanOption):
        (JSC::intlStringOption):
        (JSC::privateUseLangTag):
        (JSC::canonicalLangTag):
        (JSC::grandfatheredLangTag):
        (JSC::canonicalizeLanguageTag):
        (JSC::canonicalizeLocaleList):
        (JSC::lookupSupportedLocales):
        (JSC::bestFitSupportedLocales):
        (JSC::supportedLocales):
        (JSC::getIntlBooleanOption): Deleted.
        (JSC::getIntlStringOption): Deleted.
        (JSC::getPrivateUseLangTag): Deleted.
        (JSC::getCanonicalLangTag): Deleted.
        (JSC::getGrandfatheredLangTag): Deleted.
        * runtime/IntlObject.h:

2015-11-30  Benjamin Poulain  <bpoulain@apple.com>

        [JSC] Simplify the loop that remove useless Air instructions
        https://bugs.webkit.org/show_bug.cgi?id=151652

        Reviewed by Andreas Kling.

        * b3/air/AirEliminateDeadCode.cpp:
        (JSC::B3::Air::eliminateDeadCode):
        Use Vector's removeAllMatching() instead of custom code.

        It is likely faster too since we remove few values and Vector
        is good at doing that.

2015-11-30  Filip Pizlo  <fpizlo@apple.com>

        B3 should be be clever about choosing which child to reuse for result in two-operand commutative operations
        https://bugs.webkit.org/show_bug.cgi?id=151321

        Reviewed by Geoffrey Garen.

        When lowering a commutative operation to a two-operand instruction, you have a choice of which
        child value to move into the result tmp. For example we might have:

            @x = Add(@y, @z)

        Assuming no three-operand add is available, we could either lower it to this:

            Move %y, %x
            Add %z, %x

        or to this:

            Move %z, %x
            Add %y, %x

        Which is better depends on the likelihood of coalescing with %x. If it's more likely that %y will
        coalesce with %x, then we want to use the first form. Otherwise, we should use the second form.

        This implements two heuristics for selecting the right form, and makes those heuristics reusable
        within the B3->Air lowering by abstracting it as preferRightForResult(). For non-commutative
        operations we must use the first form, so the first form is the default. The heuristics are:

        - If the right child has only one user, then use the second form instead. This is profitable because
          that means that @z dies at the Add, so using the second form means that the Move will be coalesced
          away.

        - If one of the children is a Phi that this operation (the Add in this case) flows into via some
          Upsilon - possibly transitively through other Phis - then use the form that cases a Move on that
          child. This overrides everything else, and is meant to optimize variables that accumulate in a
          loop.

        This required adding a reusable PhiChildren analysis, so I wrote one. It has an API that is mostly
        based on iterators, and a higher-level API for looking at transitive children that is based on
        functors.

        I was originally implementing this for completeness, but when looking at how it interacted with
        imaging-gaussian-blur, I realized the need for some heuristic for the loop-accumulator case. This
        helps a lot on that benchmark. This widens the overall lead that B3 has on imaging-gaussian-blur, but
        steady-state runs that exclude compile latency still show a slight deficit. That will most likely get
        fixed by https://bugs.webkit.org/show_bug.cgi?id=151174.

        No new tests because the commutativity appears to be covered by existing tests, and anyway, there are
        no correctness implications to commuting a commutative operation.

        * CMakeLists.txt:
        * JavaScriptCore.xcodeproj/project.pbxproj:
        * b3/B3LowerToAir.cpp:
        (JSC::B3::Air::LowerToAir::LowerToAir):
        (JSC::B3::Air::LowerToAir::canBeInternal):
        (JSC::B3::Air::LowerToAir::appendUnOp):
        (JSC::B3::Air::LowerToAir::preferRightForResult):
        (JSC::B3::Air::LowerToAir::appendBinOp):
        (JSC::B3::Air::LowerToAir::lower):
        * b3/B3PhiChildren.cpp: Added.
        (JSC::B3::PhiChildren::PhiChildren):
        (JSC::B3::PhiChildren::~PhiChildren):
        * b3/B3PhiChildren.h: Added.
        (JSC::B3::PhiChildren::ValueCollection::ValueCollection):
        (JSC::B3::PhiChildren::ValueCollection::size):
        (JSC::B3::PhiChildren::ValueCollection::at):
        (JSC::B3::PhiChildren::ValueCollection::operator[]):
        (JSC::B3::PhiChildren::ValueCollection::contains):
        (JSC::B3::PhiChildren::ValueCollection::iterator::iterator):
        (JSC::B3::PhiChildren::ValueCollection::iterator::operator*):
        (JSC::B3::PhiChildren::ValueCollection::iterator::operator++):
        (JSC::B3::PhiChildren::ValueCollection::iterator::operator==):
        (JSC::B3::PhiChildren::ValueCollection::iterator::operator!=):
        (JSC::B3::PhiChildren::ValueCollection::begin):
        (JSC::B3::PhiChildren::ValueCollection::end):
        (JSC::B3::PhiChildren::UpsilonCollection::UpsilonCollection):
        (JSC::B3::PhiChildren::UpsilonCollection::size):
        (JSC::B3::PhiChildren::UpsilonCollection::at):
        (JSC::B3::PhiChildren::UpsilonCollection::operator[]):
        (JSC::B3::PhiChildren::UpsilonCollection::contains):
        (JSC::B3::PhiChildren::UpsilonCollection::begin):
        (JSC::B3::PhiChildren::UpsilonCollection::end):
        (JSC::B3::PhiChildren::UpsilonCollection::values):
        (JSC::B3::PhiChildren::UpsilonCollection::forAllTransitiveIncomingValues):
        (JSC::B3::PhiChildren::UpsilonCollection::transitivelyUses):
        (JSC::B3::PhiChildren::at):
        (JSC::B3::PhiChildren::operator[]):
        * b3/B3Procedure.cpp:
        (JSC::B3::Procedure::Procedure):
        * b3/B3Procedure.h:
        * b3/B3UseCounts.cpp:
        (JSC::B3::UseCounts::UseCounts):
        * b3/B3UseCounts.h:
        (JSC::B3::UseCounts::numUses):
        (JSC::B3::UseCounts::numUsingInstructions):
        (JSC::B3::UseCounts::operator[]): Deleted.

2015-11-30  Filip Pizlo  <fpizlo@apple.com>

        REGRESSION(r192812): This change seems to have broken the iOS builds (Requested by ryanhaddad on #webkit).
        https://bugs.webkit.org/show_bug.cgi?id=151669

        Unreviewed, fix build.

        * dfg/DFGCommon.h:

2015-11-30  Saam barati  <sbarati@apple.com>

        implement op_get_rest_length so that we can allocate the rest array with the right size from the start
        https://bugs.webkit.org/show_bug.cgi?id=151467

        Reviewed by Geoffrey Garen and Mark Lam.

        This patch implements op_get_rest_length which returns the length
        that the rest parameter array will be. We're implementing this because
        it might be a constant value in the presence of inlining in the DFG.
        We will take advantage of this optimization opportunity in a future patch:
        https://bugs.webkit.org/show_bug.cgi?id=151454
        to emit better code for op_copy_rest.

        op_get_rest_length has two operands: 
        1) a destination
        2) A constant indicating the number of parameters to skip when copying the rest array.

        op_get_rest_length lowers to a JSConstant node when we're inlined
        and not a varargs call (in this case, we statically know the arguments
        length). When that condition isn't met, we lower op_get_rest_length to 
        GetRestArray. GetRestArray produces its result as an int32.

        * bytecode/BytecodeList.json:
        * bytecode/BytecodeUseDef.h:
        (JSC::computeUsesForBytecodeOffset):
        (JSC::computeDefsForBytecodeOffset):
        * bytecode/CodeBlock.cpp:
        (JSC::CodeBlock::dumpBytecode):
        * bytecompiler/BytecodeGenerator.cpp:
        (JSC::BytecodeGenerator::emitNewArray):
        (JSC::BytecodeGenerator::emitNewArrayWithSize):
        (JSC::BytecodeGenerator::emitNewFunction):
        (JSC::BytecodeGenerator::emitExpectedFunctionSnippet):
        (JSC::BytecodeGenerator::emitRestParameter):
        * bytecompiler/BytecodeGenerator.h:
        * bytecompiler/NodesCodegen.cpp:
        (JSC::RestParameterNode::emit):
        * dfg/DFGAbstractInterpreterInlines.h:
        (JSC::DFG::AbstractInterpreter<AbstractStateType>::executeEffects):
        * dfg/DFGByteCodeParser.cpp:
        (JSC::DFG::ByteCodeParser::parseBlock):
        * dfg/DFGCapabilities.cpp:
        (JSC::DFG::capabilityLevel):
        * dfg/DFGClobberize.h:
        (JSC::DFG::clobberize):
        * dfg/DFGDoesGC.cpp:
        (JSC::DFG::doesGC):
        * dfg/DFGFixupPhase.cpp:
        (JSC::DFG::FixupPhase::fixupNode):
        * dfg/DFGMayExit.cpp:
        (JSC::DFG::mayExit):
        * dfg/DFGNode.h:
        (JSC::DFG::Node::numberOfArgumentsToSkip):
        * dfg/DFGNodeType.h:
        * dfg/DFGOperations.cpp:
        * dfg/DFGOperations.h:
        * dfg/DFGPredictionPropagationPhase.cpp:
        (JSC::DFG::PredictionPropagationPhase::propagate):
        * dfg/DFGSafeToExecute.h:
        (JSC::DFG::safeToExecute):
        * dfg/DFGSpeculativeJIT.cpp:
        (JSC::DFG::SpeculativeJIT::compileCopyRest):
        (JSC::DFG::SpeculativeJIT::compileGetRestLength):
        (JSC::DFG::SpeculativeJIT::compileNotifyWrite):
        * dfg/DFGSpeculativeJIT.h:
        (JSC::DFG::SpeculativeJIT::callOperation):
        * dfg/DFGSpeculativeJIT32_64.cpp:
        (JSC::DFG::SpeculativeJIT::compile):
        * dfg/DFGSpeculativeJIT64.cpp:
        (JSC::DFG::SpeculativeJIT::compile):
        * ftl/FTLCapabilities.cpp:
        (JSC::FTL::canCompile):
        * ftl/FTLLowerDFGToLLVM.cpp:
        (JSC::FTL::DFG::LowerDFGToLLVM::compileNode):
        (JSC::FTL::DFG::LowerDFGToLLVM::compileCopyRest):
        (JSC::FTL::DFG::LowerDFGToLLVM::compileGetRestLength):
        (JSC::FTL::DFG::LowerDFGToLLVM::compileNewObject):
        * jit/JIT.cpp:
        (JSC::JIT::privateCompileMainPass):
        * jit/JIT.h:
        * jit/JITOpcodes.cpp:
        (JSC::JIT::emit_op_copy_rest):
        (JSC::JIT::emit_op_get_rest_length):
        * llint/LowLevelInterpreter.asm:
        * llint/LowLevelInterpreter32_64.asm:
        * llint/LowLevelInterpreter64.asm:
        * runtime/CommonSlowPaths.cpp:
        (JSC::SLOW_PATH_DECL):

2015-11-30  Filip Pizlo  <fpizlo@apple.com>

        MacroAssembler needs an API for disabling scratch registers
        https://bugs.webkit.org/show_bug.cgi?id=151010

        Reviewed by Saam Barati and Michael Saboff.

        This adds two scope classes, DisallowMacroScratchRegisterUsage and
        AllowMacroScratchRegisterUsage. The default is that the scratch registers are enabled. Air
        disables them before generation.

        Henceforth the pattern inside B3 stackmap generator callbacks will be that you can only use
        AllowMacroScratchRegisterUsage if you've either supplied the scratch register as a clobbered
        register and arranged for all of the stackmap values to be late uses, or you're writing a test
        and you're OK with it being fragile with respect to scratch registers. The latter holds in most
        of testb3.

        * JavaScriptCore.xcodeproj/project.pbxproj:
        * assembler/AbstractMacroAssembler.h:
        (JSC::optimizeForX86):
        (JSC::AbstractMacroAssembler::setTempRegisterValid):
        * assembler/AllowMacroScratchRegisterUsage.h: Added.
        (JSC::AllowMacroScratchRegisterUsage::AllowMacroScratchRegisterUsage):
        (JSC::AllowMacroScratchRegisterUsage::~AllowMacroScratchRegisterUsage):
        * assembler/DisallowMacroScratchRegisterUsage.h: Added.
        (JSC::DisallowMacroScratchRegisterUsage::DisallowMacroScratchRegisterUsage):
        (JSC::DisallowMacroScratchRegisterUsage::~DisallowMacroScratchRegisterUsage):
        * assembler/MacroAssemblerX86Common.h:
        (JSC::MacroAssemblerX86Common::scratchRegister):
        (JSC::MacroAssemblerX86Common::loadDouble):
        (JSC::MacroAssemblerX86Common::branchConvertDoubleToInt32):
        * assembler/MacroAssemblerX86_64.h:
        (JSC::MacroAssemblerX86_64::add32):
        (JSC::MacroAssemblerX86_64::and32):
        (JSC::MacroAssemblerX86_64::or32):
        (JSC::MacroAssemblerX86_64::sub32):
        (JSC::MacroAssemblerX86_64::load8):
        (JSC::MacroAssemblerX86_64::addDouble):
        (JSC::MacroAssemblerX86_64::convertInt32ToDouble):
        (JSC::MacroAssemblerX86_64::store32):
        (JSC::MacroAssemblerX86_64::store8):
        (JSC::MacroAssemblerX86_64::callWithSlowPathReturnType):
        (JSC::MacroAssemblerX86_64::call):
        (JSC::MacroAssemblerX86_64::jump):
        (JSC::MacroAssemblerX86_64::tailRecursiveCall):
        (JSC::MacroAssemblerX86_64::makeTailRecursiveCall):
        (JSC::MacroAssemblerX86_64::branchAdd32):
        (JSC::MacroAssemblerX86_64::add64):
        (JSC::MacroAssemblerX86_64::addPtrNoFlags):
        (JSC::MacroAssemblerX86_64::and64):
        (JSC::MacroAssemblerX86_64::lshift64):
        (JSC::MacroAssemblerX86_64::or64):
        (JSC::MacroAssemblerX86_64::sub64):
        (JSC::MacroAssemblerX86_64::store64):
        (JSC::MacroAssemblerX86_64::store64WithAddressOffsetPatch):
        (JSC::MacroAssemblerX86_64::branch64):
        (JSC::MacroAssemblerX86_64::branchPtr):
        (JSC::MacroAssemblerX86_64::branchTest64):
        (JSC::MacroAssemblerX86_64::test64):
        (JSC::MacroAssemblerX86_64::branchPtrWithPatch):
        (JSC::MacroAssemblerX86_64::branch32WithPatch):
        (JSC::MacroAssemblerX86_64::storePtrWithPatch):
        (JSC::MacroAssemblerX86_64::branch8):
        (JSC::MacroAssemblerX86_64::branchTest8):
        (JSC::MacroAssemblerX86_64::convertInt64ToDouble):
        (JSC::MacroAssemblerX86_64::readCallTarget):
        (JSC::MacroAssemblerX86_64::haveScratchRegisterForBlinding):
        (JSC::MacroAssemblerX86_64::scratchRegisterForBlinding):
        (JSC::MacroAssemblerX86_64::canJumpReplacePatchableBranchPtrWithPatch):
        (JSC::MacroAssemblerX86_64::canJumpReplacePatchableBranch32WithPatch):
        (JSC::MacroAssemblerX86_64::revertJumpReplacementToPatchableBranchPtrWithPatch):
        (JSC::MacroAssemblerX86_64::revertJumpReplacementToPatchableBranch32WithPatch):
        (JSC::MacroAssemblerX86_64::revertJumpReplacementToBranchPtrWithPatch):
        (JSC::MacroAssemblerX86_64::repatchCall):
        (JSC::MacroAssemblerX86_64::add64AndSetFlags):
        * b3/air/AirGenerate.cpp:
        (JSC::B3::Air::generate):
        * b3/testb3.cpp:
        (JSC::B3::testSimplePatchpoint):
        (JSC::B3::testSimplePatchpointWithoutOuputClobbersGPArgs):
        (JSC::B3::testSimplePatchpointWithOuputClobbersGPArgs):
        (JSC::B3::testSimplePatchpointWithoutOuputClobbersFPArgs):
        (JSC::B3::testSimplePatchpointWithOuputClobbersFPArgs):
        (JSC::B3::testPatchpointCallArg):
        (JSC::B3::testPatchpointFixedRegister):
        (JSC::B3::testPatchpointAny):
        (JSC::B3::testPatchpointAnyImm):
        (JSC::B3::testSimpleCheck):
        (JSC::B3::testCheckLessThan):
        (JSC::B3::testCheckMegaCombo):
        (JSC::B3::testCheckAddImm):
        (JSC::B3::testCheckAddImmCommute):
        (JSC::B3::testCheckAddImmSomeRegister):
        (JSC::B3::testCheckAdd):
        (JSC::B3::testCheckAdd64):
        (JSC::B3::testCheckAddFoldFail):
        (JSC::B3::testCheckSubImm):
        (JSC::B3::testCheckSubBadImm):
        (JSC::B3::testCheckSub):
        (JSC::B3::testCheckSub64):
        (JSC::B3::testCheckSubFoldFail):
        (JSC::B3::testCheckNeg):
        (JSC::B3::testCheckNeg64):
        (JSC::B3::testCheckMul):
        (JSC::B3::testCheckMulMemory):
        (JSC::B3::testCheckMul2):
        (JSC::B3::testCheckMul64):
        (JSC::B3::testCheckMulFoldFail):
        (JSC::B3::genericTestCompare):
        * dfg/DFGCommon.h:
        * jit/GPRInfo.h:
        (JSC::GPRInfo::toRegister):
        (JSC::GPRInfo::reservedRegisters):

2015-11-26  Mark Lam  <mark.lam@apple.com>

        [ARM64] stress/op_div.js is failing on some divide by 0 cases.
        https://bugs.webkit.org/show_bug.cgi?id=151515

        Reviewed by Saam Barati.

        * dfg/DFGSpeculativeJIT.cpp:
        (JSC::DFG::SpeculativeJIT::compileArithDiv):
        - Added a check for the divide by zero case.
        * tests/stress/op_div.js:
        - Un-skipped the test.

2015-11-27  Csaba Osztrogon√°c  <ossy@webkit.org>

        [cmake] Add testb3 to the build system
        https://bugs.webkit.org/show_bug.cgi?id=151619

        Reviewed by Gyuyoung Kim.

        * shell/CMakeLists.txt:

2015-11-27  Csaba Osztrogon√°c  <ossy@webkit.org>

        Use mark pragmas only if it is supported
        https://bugs.webkit.org/show_bug.cgi?id=151621

        Reviewed by Mark Lam.

        * b3/air/AirIteratedRegisterCoalescing.cpp:

2015-11-27  Csaba Osztrogon√°c  <ossy@webkit.org>

        Fix the ENABLE(B3_JIT) build with GCC in B3Procedure.h
        https://bugs.webkit.org/show_bug.cgi?id=151620

        Reviewed by Mark Lam.

        * b3/B3Procedure.h:

2015-11-27  Csaba Osztrogon√°c  <ossy@webkit.org>

        [cmake] Add new B3 source files to the build system
        https://bugs.webkit.org/show_bug.cgi?id=151618

        Reviewed by Gyuyoung Kim.

        * CMakeLists.txt:

2015-11-26  Carlos Garcia Campos  <cgarcia@igalia.com>

        [GLIB] Implement garbage collector timers
        https://bugs.webkit.org/show_bug.cgi?id=151391

        Reviewed by ≈Ωan Dober≈°ek.

        Add GLib implementation using GSource.

        * heap/EdenGCActivityCallback.cpp:
        * heap/FullGCActivityCallback.cpp:
        * heap/GCActivityCallback.cpp:
        (JSC::GCActivityCallback::GCActivityCallback):
        (JSC::GCActivityCallback::scheduleTimer):
        (JSC::GCActivityCallback::cancelTimer):
        * heap/GCActivityCallback.h:
        * heap/Heap.cpp:
        (JSC::Heap::Heap):
        * heap/HeapTimer.cpp:
        (JSC::HeapTimer::HeapTimer):
        (JSC::HeapTimer::~HeapTimer):
        (JSC::HeapTimer::timerDidFire):
        * heap/HeapTimer.h:
        * heap/IncrementalSweeper.cpp:
        (JSC::IncrementalSweeper::IncrementalSweeper):
        (JSC::IncrementalSweeper::scheduleTimer):
        (JSC::IncrementalSweeper::cancelTimer):
        * heap/IncrementalSweeper.h:

2015-11-24  Caitlin Potter  <caitp@igalia.com>

        [JSC] support Computed Property Names in destructuring Patterns
        https://bugs.webkit.org/show_bug.cgi?id=151494

        Reviewed by Saam Barati.

        Add support for computed property names in destructuring BindingPatterns
        and AssignmentPatterns.

        Productions BindingProperty(1) and AssignmentProperty(2) allow for any valid
        PropertName(3), including ComputedPropertyName(4)

        1: http://tc39.github.io/ecma262/#prod-BindingProperty
        2: http://tc39.github.io/ecma262/#prod-AssignmentProperty
        3: http://tc39.github.io/ecma262/#prod-PropertyName
        4: http://tc39.github.io/ecma262/#prod-ComputedPropertyName

        * bytecompiler/NodesCodegen.cpp:
        (JSC::ObjectPatternNode::bindValue):
        * parser/ASTBuilder.h:
        (JSC::ASTBuilder::appendObjectPatternEntry):
        * parser/Nodes.h:
        (JSC::ObjectPatternNode::appendEntry):
        * parser/Parser.cpp:
        (JSC::Parser<LexerType>::parseDestructuringPattern):
        * parser/SyntaxChecker.h:
        (JSC::SyntaxChecker::operatorStackPop):
        * tests/es6.yaml:
        * tests/es6/destructuring_assignment_computed_properties.js: Added.
        (test):
        (test.computeName):
        (test.loadValue):
        (test.out.get a):
        (test.out.set a):
        (test.out.get b):
        (test.out.set b):
        (test.out.get c):
        (test.out.set c):
        (test.get var):

2015-11-24  Commit Queue  <commit-queue@webkit.org>

        Unreviewed, rolling out r192536, r192722, and r192743.
        https://bugs.webkit.org/show_bug.cgi?id=151593

        Still causing trouble. (Requested by kling on #webkit).

        Reverted changesets:

        "[JSC] JSPropertyNameEnumerator could be destructorless."
        https://bugs.webkit.org/show_bug.cgi?id=151242
        http://trac.webkit.org/changeset/192536

        "REGRESSION(r192536): Null pointer dereference in
        JSPropertyNameEnumerator::visitChildren()."
        https://bugs.webkit.org/show_bug.cgi?id=151495
        http://trac.webkit.org/changeset/192722

        "REGRESSION(r192536): Null pointer dereference in
        JSPropertyNameEnumerator::visitChildren()."
        https://bugs.webkit.org/show_bug.cgi?id=151495
        http://trac.webkit.org/changeset/192743

2015-11-23  Brian Burg  <bburg@apple.com>

        Unreviewed, fix the Mac CMake build after r192793.

        * PlatformMac.cmake:

2015-11-20  Brian Burg  <bburg@apple.com>

        Web Inspector: RemoteInspector should track targets and connections for remote automation
        https://bugs.webkit.org/show_bug.cgi?id=151042

        Reviewed by Joseph Pecoraro.

        Refactor RemoteInspector so it can be used to send listings of different target types.
        First, rename Debuggable to RemoteInspectionTarget, and pull things not specific to
        remote inspection into the base class RemoteControllableTarget and its Connection class.

        Add a new RemoteControllableTarget called RemoteAutomationTarget, used by UIProcess
        to support remote UI automation via webinspectord. On the protocol side, this target
        uses a new WIRTypeKey called WIRTypeAutomation to distiguish the listing from
        Web and JavaScript listings and avoid inventing a new listing mechanism.

        * API/JSContextRef.cpp:
        (JSGlobalContextGetDebuggerRunLoop):
        (JSGlobalContextSetDebuggerRunLoop):
        * JavaScriptCore.xcodeproj/project.pbxproj:
        * inspector/InspectorFrontendChannel.h:
        * inspector/remote/RemoteAutomationTarget.cpp: Added.
        (Inspector::RemoteAutomationTarget::setAutomationAllowed): Added.
        * inspector/remote/RemoteAutomationTarget.h: Added.
        * inspector/remote/RemoteConnectionToTarget.h: Renamed from Source/JavaScriptCore/inspector/remote/RemoteInspectorDebuggableConnection.h.
        (Inspector::RemoteTargetBlock::RemoteTargetBlock):
        (Inspector::RemoteTargetBlock::~RemoteTargetBlock):
        (Inspector::RemoteTargetBlock::operator=):
        (Inspector::RemoteTargetBlock::operator()):
        * inspector/remote/RemoteConnectionToTarget.mm: Renamed from Source/JavaScriptCore/inspector/remote/RemoteInspectorDebuggableConnection.mm.
        (Inspector::RemoteTargetHandleRunSourceGlobal):
        (Inspector::RemoteTargetQueueTaskOnGlobalQueue):
        (Inspector::RemoteTargetInitializeGlobalQueue):
        (Inspector::RemoteTargetHandleRunSourceWithInfo):
        (Inspector::RemoteConnectionToTarget::RemoteConnectionToTarget):
        (Inspector::RemoteConnectionToTarget::~RemoteConnectionToTarget):
        (Inspector::RemoteConnectionToTarget::destination):
        (Inspector::RemoteConnectionToTarget::connectionIdentifier):
        (Inspector::RemoteConnectionToTarget::dispatchAsyncOnTarget):
        (Inspector::RemoteConnectionToTarget::setup):
        (Inspector::RemoteConnectionToTarget::targetClosed):
        (Inspector::RemoteConnectionToTarget::close):
        (Inspector::RemoteConnectionToTarget::sendMessageToTarget):
        (Inspector::RemoteConnectionToTarget::sendMessageToFrontend):
        (Inspector::RemoteConnectionToTarget::setupRunLoop):
        (Inspector::RemoteConnectionToTarget::teardownRunLoop):
        (Inspector::RemoteConnectionToTarget::queueTaskOnPrivateRunLoop):
        * inspector/remote/RemoteControllableTarget.cpp: Added.
        (Inspector::RemoteControllableTarget::~RemoteControllableTarget):
        (Inspector::RemoteControllableTarget::init):
        (Inspector::RemoteControllableTarget::update):
        * inspector/remote/RemoteControllableTarget.h: Added.
        * inspector/remote/RemoteInspectionTarget.cpp: Renamed from Source/JavaScriptCore/inspector/remote/RemoteInspectorDebuggable.cpp.
        (Inspector::RemoteInspectionTarget::remoteControlAllowed):
        (Inspector::RemoteInspectionTarget::setRemoteDebuggingAllowed):
        (Inspector::RemoteInspectionTarget::pauseWaitingForAutomaticInspection):
        (Inspector::RemoteInspectionTarget::unpauseForInitializedInspector):
        * inspector/remote/RemoteInspectionTarget.h: Renamed from Source/JavaScriptCore/inspector/remote/RemoteInspectorDebuggable.h.
        (isType):
        * inspector/remote/RemoteInspector.h:

            Code to manage Debuggables now works with RemoteControllableTargets and doesn't
            care whether the target is for Inspection or Automation. Listing data with target-
            and type-specific information are captured when clients call into RemoteInspector
            since that's the easiest time to gather this information on the right thread.
            Use the is<> / downcast<> machinery when we need a concrete Target type.

        * inspector/remote/RemoteInspector.mm:
        (Inspector::RemoteInspector::nextAvailableIdentifier):
        (Inspector::RemoteInspector::registerTarget): renamed from registerDebuggable.
        (Inspector::RemoteInspector::unregisterTarget): renamed from unregisterDebuggable.
        (Inspector::RemoteInspector::updateTarget): renamed from updateDebuggable.
        (Inspector::RemoteInspector::updateAutomaticInspectionCandidate):
        (Inspector::RemoteInspector::sendMessageToRemote):
        (Inspector::RemoteInspector::setupFailed):
        (Inspector::RemoteInspector::stopInternal):
        (Inspector::RemoteInspector::setupXPCConnectionIfNeeded):
        (Inspector::RemoteInspector::xpcConnectionFailed):
        (Inspector::RemoteInspector::listingForTarget):
        (Inspector::RemoteInspector::listingForInspectionTarget):
        (Inspector::RemoteInspector::listingForAutomationTarget):
        (Inspector::RemoteInspector::pushListingsNow):
        (Inspector::RemoteInspector::pushListingsSoon):
        (Inspector::RemoteInspector::receivedSetupMessage):
        (Inspector::RemoteInspector::receivedDataMessage):
        (Inspector::RemoteInspector::receivedDidCloseMessage):
        (Inspector::RemoteInspector::receivedGetListingMessage):
        (Inspector::RemoteInspector::receivedIndicateMessage):
        (Inspector::RemoteInspector::receivedConnectionDiedMessage):
        (Inspector::RemoteInspector::RemoteInspector): Deleted.
        (Inspector::RemoteInspector::registerDebuggable): Deleted.
        (Inspector::RemoteInspector::unregisterDebuggable): Deleted.
        (Inspector::RemoteInspector::updateDebuggable): Deleted.
        (Inspector::RemoteInspector::updateDebuggableAutomaticInspectCandidate): Deleted.
        (Inspector::RemoteInspector::sendMessageToRemoteFrontend): Deleted.
        (Inspector::RemoteInspector::listingForDebuggable): Deleted.
        (Inspector::RemoteInspector::pushListingNow): Deleted.
        (Inspector::RemoteInspector::pushListingSoon): Deleted.
        * inspector/remote/RemoteInspectorConstants.h:
        * runtime/JSGlobalObjectDebuggable.cpp:
        (JSC::JSGlobalObjectDebuggable::dispatchMessageFromRemote):
        (JSC::JSGlobalObjectDebuggable::pauseWaitingForAutomaticInspection):
        (JSC::JSGlobalObjectDebuggable::dispatchMessageFromRemoteFrontend): Deleted.
        * runtime/JSGlobalObjectDebuggable.h:

2015-11-23  Brian Burg  <bburg@apple.com>

        Rename JavaScriptCore builtins files to match exposed object names
        https://bugs.webkit.org/show_bug.cgi?id=151549

        Reviewed by Youenn Fablet.

        As a subtask of unifying code generation for WebCore and JSC builtins, we need to get rid of
        differences between builtins filenames (e.g., Promise.prototype.js) and the name of the
        generated Builtin object (PromisePrototype).

        If we don't do this, then both build systems need special hacks to normalize the object name
        from the file name. It's easier to just normalize the filename.

        * CMakeLists.txt:
        * DerivedSources.make:
        * JavaScriptCore.xcodeproj/project.pbxproj:
        * builtins/ArrayIteratorPrototype.js: Renamed from Source/JavaScriptCore/builtins/ArrayIterator.prototype.js.
        * builtins/ArrayPrototype.js: Renamed from Source/JavaScriptCore/builtins/Array.prototype.js.
        * builtins/FunctionPrototype.js: Renamed from Source/JavaScriptCore/builtins/Function.prototype.js.
        * builtins/IteratorPrototype.js: Renamed from Source/JavaScriptCore/builtins/Iterator.prototype.js.
        * builtins/PromiseOperations.js: Renamed from Source/JavaScriptCore/builtins/Operations.Promise.js.
        * builtins/PromisePrototype.js: Renamed from Source/JavaScriptCore/builtins/Promise.prototype.js.
        * builtins/StringIteratorPrototype.js: Renamed from Source/JavaScriptCore/builtins/StringIterator.prototype.js.
        * builtins/TypedArrayPrototype.js: Renamed from Source/JavaScriptCore/builtins/TypedArray.prototype.js.

2015-11-23  Andreas Kling  <akling@apple.com>

        REGRESSION(r192536): Null pointer dereference in JSPropertyNameEnumerator::visitChildren().
        <https://webkit.org/b/151495>

        Reviewed by Mark Lam

        The test I added when fixing this bug the first time caught another bug when
        run on 32-bit: jsString() can also cause GC, so we have to make sure that
        JSPropertyNameEnumerator::m_propertyNames is null until after the array it
        points to has been populated.

        Test: property-name-enumerator-gc-151495.js

        * runtime/JSPropertyNameEnumerator.cpp:
        (JSC::JSPropertyNameEnumerator::finishCreation):

== Rolled over to ChangeLog-2015-11-21 ==
