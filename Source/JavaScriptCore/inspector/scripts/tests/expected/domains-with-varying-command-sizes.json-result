### Begin File: InspectorAlternateBackendDispatchers.h
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013, 2014 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from domains-with-varying-command-sizes.json
// by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#ifndef InspectorAlternateBackendDispatchers_h
#define InspectorAlternateBackendDispatchers_h

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)

#include "InspectorProtocolTypes.h"
#include <JavaScriptCore/InspectorBackendDispatcher.h>

namespace Inspector {

class AlternateInspectorBackendDispatcher {
public:
    void setBackendDispatcher(PassRefPtr<InspectorBackendDispatcher> dispatcher) { m_backendDispatcher = dispatcher; }
    InspectorBackendDispatcher* backendDispatcher() const { return m_backendDispatcher.get(); }
private:
    RefPtr<InspectorBackendDispatcher> m_backendDispatcher;
};


class AlternateInspectorNetwork1BackendDispatcher : public AlternateInspectorBackendDispatcher {
public:
    virtual ~AlternateInspectorNetwork1BackendDispatcher() { }
    virtual void loadResource1(long callId) = 0;
};
class AlternateInspectorNetwork3BackendDispatcher : public AlternateInspectorBackendDispatcher {
public:
    virtual ~AlternateInspectorNetwork3BackendDispatcher() { }
    virtual void loadResource1(long callId) = 0;
    virtual void loadResource2(long callId) = 0;
    virtual void loadResource3(long callId) = 0;
    virtual void loadResource4(long callId) = 0;
    virtual void loadResource5(long callId) = 0;
    virtual void loadResource6(long callId) = 0;
    virtual void loadResource7(long callId) = 0;
};

} // namespace Inspector

#endif // ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)

#endif // !defined(InspectorAlternateBackendDispatchers_h)
### End File: InspectorAlternateBackendDispatchers.h

### Begin File: InspectorBackendCommands.js
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013, 2014 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from domains-with-varying-command-sizes.json
// by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

// Network1.
InspectorBackend.registerCommand("Network1.loadResource1", [], []);
InspectorBackend.activateDomain("Network1");

// Network3.
InspectorBackend.registerCommand("Network3.loadResource1", [], []);
InspectorBackend.registerCommand("Network3.loadResource2", [], []);
InspectorBackend.registerCommand("Network3.loadResource3", [], []);
InspectorBackend.registerCommand("Network3.loadResource4", [], []);
InspectorBackend.registerCommand("Network3.loadResource5", [], []);
InspectorBackend.registerCommand("Network3.loadResource6", [], []);
InspectorBackend.registerCommand("Network3.loadResource7", [], []);
InspectorBackend.activateDomain("Network3");
### End File: InspectorBackendCommands.js

### Begin File: InspectorBackendDispatchers.h
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013, 2014 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from domains-with-varying-command-sizes.json
// by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#ifndef InspectorBackendDispatchers_h
#define InspectorBackendDispatchers_h

#if ENABLE(INSPECTOR)

#include "InspectorProtocolObjects.h"
#include <inspector/InspectorBackendDispatcher.h>
#include <wtf/PassRefPtr.h>
#include <wtf/text/WTFString.h>

namespace Inspector {

typedef String ErrorString;

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
class AlternateInspectorNetwork1BackendDispatcher;
class AlternateInspectorNetwork3BackendDispatcher;
#endif // ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)

class InspectorNetwork1BackendDispatcherHandler {
public:
    virtual void loadResource1(ErrorString&) = 0;
protected:
    virtual ~InspectorNetwork1BackendDispatcherHandler();
};

class InspectorNetwork3BackendDispatcherHandler {
public:
    virtual void loadResource1(ErrorString&) = 0;
    virtual void loadResource2(ErrorString&) = 0;
    virtual void loadResource3(ErrorString&) = 0;
    virtual void loadResource4(ErrorString&) = 0;
    virtual void loadResource5(ErrorString&) = 0;
    virtual void loadResource6(ErrorString&) = 0;
    virtual void loadResource7(ErrorString&) = 0;
protected:
    virtual ~InspectorNetwork3BackendDispatcherHandler();
};

class InspectorNetwork1BackendDispatcher final : public Inspector::InspectorSupplementalBackendDispatcher {
public:
    static PassRefPtr<InspectorNetwork1BackendDispatcher> create(Inspector::InspectorBackendDispatcher*, InspectorNetwork1BackendDispatcherHandler*);
    virtual void dispatch(long callId, const String& method, PassRefPtr<Inspector::InspectorObject> message) override;
private:
    void loadResource1(long callId, const Inspector::InspectorObject& message);
private:
    InspectorNetwork1BackendDispatcher(Inspector::InspectorBackendDispatcher*, InspectorNetwork1BackendDispatcherHandler*);
    InspectorNetwork1BackendDispatcherHandler* m_agent;
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
public:
    void setAlternateDispatcher(AlternateInspectorNetwork1BackendDispatcher* alternateDispatcher) { m_alternateDispatcher = alternateDispatcher; }
private:
    AlternateInspectorNetwork1BackendDispatcher* m_alternateDispatcher;
#endif
};

class InspectorNetwork3BackendDispatcher final : public Inspector::InspectorSupplementalBackendDispatcher {
public:
    static PassRefPtr<InspectorNetwork3BackendDispatcher> create(Inspector::InspectorBackendDispatcher*, InspectorNetwork3BackendDispatcherHandler*);
    virtual void dispatch(long callId, const String& method, PassRefPtr<Inspector::InspectorObject> message) override;
private:
    void loadResource1(long callId, const Inspector::InspectorObject& message);
    void loadResource2(long callId, const Inspector::InspectorObject& message);
    void loadResource3(long callId, const Inspector::InspectorObject& message);
    void loadResource4(long callId, const Inspector::InspectorObject& message);
    void loadResource5(long callId, const Inspector::InspectorObject& message);
    void loadResource6(long callId, const Inspector::InspectorObject& message);
    void loadResource7(long callId, const Inspector::InspectorObject& message);
private:
    InspectorNetwork3BackendDispatcher(Inspector::InspectorBackendDispatcher*, InspectorNetwork3BackendDispatcherHandler*);
    InspectorNetwork3BackendDispatcherHandler* m_agent;
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
public:
    void setAlternateDispatcher(AlternateInspectorNetwork3BackendDispatcher* alternateDispatcher) { m_alternateDispatcher = alternateDispatcher; }
private:
    AlternateInspectorNetwork3BackendDispatcher* m_alternateDispatcher;
#endif
};

} // namespace Inspector

#endif // ENABLE(INSPECTOR)

#endif // !defined(InspectorBackendDispatchers_h)
### End File: InspectorBackendDispatchers.h

### Begin File: InspectorBackendDispatchers.cpp
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013, 2014 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from domains-with-varying-command-sizes.json
// by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#include "config.h"
#include "InspectorBackendDispatchers.h"

#if ENABLE(INSPECTOR)

#include <inspector/InspectorFrontendChannel.h>
#include <inspector/InspectorValues.h>
#include <wtf/text/CString.h>

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
#include "InspectorAlternateBackendDispatchers.h"
#endif

namespace Inspector {

InspectorNetwork1BackendDispatcherHandler::~InspectorNetwork1BackendDispatcherHandler() { }
InspectorNetwork3BackendDispatcherHandler::~InspectorNetwork3BackendDispatcherHandler() { }

PassRefPtr<InspectorNetwork1BackendDispatcher> InspectorNetwork1BackendDispatcher::create(InspectorBackendDispatcher* backendDispatcher, InspectorNetwork1BackendDispatcherHandler* agent)
{
    return adoptRef(new InspectorNetwork1BackendDispatcher(backendDispatcher, agent));
}

InspectorNetwork1BackendDispatcher::InspectorNetwork1BackendDispatcher(InspectorBackendDispatcher* backendDispatcher, InspectorNetwork1BackendDispatcherHandler* agent)
    : InspectorSupplementalBackendDispatcher(backendDispatcher)
    , m_agent(agent)
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    , m_alternateDispatcher(nullptr)
#endif
{
    m_backendDispatcher->registerDispatcherForDomain(ASCIILiteral("Network1"), this);
}

void InspectorNetwork1BackendDispatcher::dispatch(long callId, const String& method, PassRefPtr<InspectorObject> message)
{
    Ref<InspectorNetwork1BackendDispatcher> protect(*this);

    if (method == "loadResource1")
        loadResource1(callId, *message.get());
    else
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::MethodNotFound, makeString('\'', "Network1", '.', method, "' was not found"));
}

void InspectorNetwork1BackendDispatcher::loadResource1(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->loadResource1(callId);
        return;
    }
#endif

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->loadResource1(error);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

PassRefPtr<InspectorNetwork3BackendDispatcher> InspectorNetwork3BackendDispatcher::create(InspectorBackendDispatcher* backendDispatcher, InspectorNetwork3BackendDispatcherHandler* agent)
{
    return adoptRef(new InspectorNetwork3BackendDispatcher(backendDispatcher, agent));
}

InspectorNetwork3BackendDispatcher::InspectorNetwork3BackendDispatcher(InspectorBackendDispatcher* backendDispatcher, InspectorNetwork3BackendDispatcherHandler* agent)
    : InspectorSupplementalBackendDispatcher(backendDispatcher)
    , m_agent(agent)
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    , m_alternateDispatcher(nullptr)
#endif
{
    m_backendDispatcher->registerDispatcherForDomain(ASCIILiteral("Network3"), this);
}

void InspectorNetwork3BackendDispatcher::dispatch(long callId, const String& method, PassRefPtr<InspectorObject> message)
{
    Ref<InspectorNetwork3BackendDispatcher> protect(*this);

    typedef void (InspectorNetwork3BackendDispatcher::*CallHandler)(long callId, const Inspector::InspectorObject& message);
    typedef HashMap<String, CallHandler> DispatchMap;
    DEPRECATED_DEFINE_STATIC_LOCAL(DispatchMap, dispatchMap, ());
    if (dispatchMap.isEmpty()) {
        static const struct MethodTable {
            const char* name;
            CallHandler handler;
        } commands[] = {
            { "loadResource1", &InspectorNetwork3BackendDispatcher::loadResource1 },
            { "loadResource2", &InspectorNetwork3BackendDispatcher::loadResource2 },
            { "loadResource3", &InspectorNetwork3BackendDispatcher::loadResource3 },
            { "loadResource4", &InspectorNetwork3BackendDispatcher::loadResource4 },
            { "loadResource5", &InspectorNetwork3BackendDispatcher::loadResource5 },
            { "loadResource6", &InspectorNetwork3BackendDispatcher::loadResource6 },
            { "loadResource7", &InspectorNetwork3BackendDispatcher::loadResource7 },
        };
        size_t length = WTF_ARRAY_LENGTH(commands);
        for (size_t i = 0; i < length; ++i)
            dispatchMap.add(commands[i].name, commands[i].handler);
    }

    HashMap<String, CallHandler>::iterator it = dispatchMap.find(method);
    if (it == dispatchMap.end()) {
        m_backendDispatcher->reportProtocolError(&callId, InspectorBackendDispatcher::MethodNotFound, makeString('\'', "Network3", '.', method, "' was not found"));
        return;
    }

    ((*this).*it->value)(callId, *message.get());
}

void InspectorNetwork3BackendDispatcher::loadResource1(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->loadResource1(callId);
        return;
    }
#endif

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->loadResource1(error);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorNetwork3BackendDispatcher::loadResource2(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->loadResource2(callId);
        return;
    }
#endif

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->loadResource2(error);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorNetwork3BackendDispatcher::loadResource3(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->loadResource3(callId);
        return;
    }
#endif

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->loadResource3(error);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorNetwork3BackendDispatcher::loadResource4(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->loadResource4(callId);
        return;
    }
#endif

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->loadResource4(error);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorNetwork3BackendDispatcher::loadResource5(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->loadResource5(callId);
        return;
    }
#endif

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->loadResource5(error);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorNetwork3BackendDispatcher::loadResource6(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->loadResource6(callId);
        return;
    }
#endif

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->loadResource6(error);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

void InspectorNetwork3BackendDispatcher::loadResource7(long callId, const InspectorObject&)
{
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->loadResource7(callId);
        return;
    }
#endif

    ErrorString error;
    RefPtr<InspectorObject> result = InspectorObject::create();
    m_agent->loadResource7(error);

    m_backendDispatcher->sendResponse(callId, result.release(), error);
}

} // namespace Inspector

#endif // ENABLE(INSPECTOR)

### End File: InspectorBackendDispatchers.cpp

### Begin File: InspectorFrontendDispatchers.h
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013, 2014 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from domains-with-varying-command-sizes.json
// by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#ifndef InspectorFrontendDispatchers_h
#define InspectorFrontendDispatchers_h

#if ENABLE(INSPECTOR)

#include "InspectorProtocolObjects.h"
#include <inspector/InspectorFrontendChannel.h>
#include <inspector/InspectorValues.h>
#include <wtf/PassRefPtr.h>
#include <wtf/text/WTFString.h>

namespace Inspector {



} // namespace Inspector

#endif // ENABLE(INSPECTOR)

#endif // !defined(InspectorFrontendDispatchers_h)
### End File: InspectorFrontendDispatchers.h

### Begin File: InspectorFrontendDispatchers.cpp
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013, 2014 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from domains-with-varying-command-sizes.json
// by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#include "config.h"
#include "InspectorFrontendDispatchers.h"

#if ENABLE(INSPECTOR)

#include <wtf/text/CString.h>

namespace Inspector {

} // namespace Inspector

#endif // ENABLE(INSPECTOR)

### End File: InspectorFrontendDispatchers.cpp

### Begin File: InspectorProtocolObjects.h
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013, 2014 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from domains-with-varying-command-sizes.json
// by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#ifndef InspectorProtocolObjects_h
#define InspectorProtocolObjects_h

#if ENABLE(INSPECTOR)

#include <inspector/InspectorProtocolTypes.h>
#include <wtf/Assertions.h>
#include <wtf/PassRefPtr.h>

namespace Inspector {



namespace Protocol {



// Typedefs.
namespace Network2 {
/* Unique loader identifier. */
typedef String LoaderId;
} // Network2
// End of typedefs.

String getEnumConstantValue(int code);

template<typename T> String getEnumConstantValue(T enumValue)
{
    return getEnumConstantValue(static_cast<int>(enumValue));
}



} // namespace Protocol

} // namespace Inspector

#endif // ENABLE(INSPECTOR)

#endif // !defined(InspectorProtocolObjects_h)
### End File: InspectorProtocolObjects.h

### Begin File: InspectorProtocolObjects.cpp
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013, 2014 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from domains-with-varying-command-sizes.json
// by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#include "config.h"
#include "InspectorProtocolObjects.h"

#if ENABLE(INSPECTOR)

#include <wtf/text/CString.h>

namespace Inspector {

namespace Protocol {

static const char* const enum_constant_values[] = {
};

String getEnumConstantValue(int code) {
    return enum_constant_values[code];
}



} // namespace Protocol

} // namespace Inspector

#endif // ENABLE(INSPECTOR)

### End File: InspectorProtocolObjects.cpp
