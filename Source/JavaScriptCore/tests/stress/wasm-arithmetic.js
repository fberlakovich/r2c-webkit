//@ skip

function shouldBe(actual, expected) {
    if (actual !== expected)
        throw new Error('bad value: ' + actual);
}

function shouldThrow(func, message) {
    var error = null;
    try {
        func();
    } catch (e) {
        error = e;
    }
    if (!error)
        throw new Error("not thrown.");
    if (String(error) !== message)
        throw new Error("bad error: " + String(error));
}

/*
wasm/arithmetic.wasm is generated by pack-asmjs <https://github.com/WebAssembly/polyfill-prototype-1> from the following script:

function asmModule(global, env, buffer) {
    "use asm";

    var clz32 = global.Math.clz32;
    var abs = global.Math.abs;

    function negate() {
        var x = 0;
        x = 42;
        return -x;
    }

    function addSubtract() {
        return ((10 + 40) - 8) | 0;
    }

    function addOverflow() {
        return (2147483647 + 1) | 0;
    }

    function multiply() {
        return (6 * 7) | 0;
    }

    function multiplyOverflow() {
        return (-2147483648 * -1) | 0;
    }

    function divide() {
        return (42 / 5) | 0;
    }

    function divideByZero() {
        return (1 / 0) | 0;
    }

    function divideOverflow() {
        return (-2147483648 / -1) | 0;
    }

    function unsignedDivide() {
        return ((-1 >>> 0) / 2) | 0;
    }

    function unsignedDivideByZero() {
        return ((-1 >>> 0) / 0) | 0;
    }

    function modulo() {
        return (42 % 5) | 0;
    }

    function moduloNegative() {
        return (-42 % 5) | 0;
    }

    function moduloZero() {
        return (1 % 0) | 0;
    }

    function moduloOverflow() {
        return (-2147483648 % -1) | 0;
    }

    function unsignedModulo() {
        return ((-1 >>> 0) % 100000) | 0;
    }

    function unsignedModuloZero() {
        return ((-1 >>> 0) % 0) | 0;
    }

    function bitNot() {
        return ~1;
    }

    function bitOr() {
        return 3 | 5;
    }

    function bitAnd() {
        return 3 & 5;
    }

    function bitXor() {
        return 3 ^ 5;
    }

    function leftShift() {
        return 1 << 16;
    }

    function arithmeticRightShift() {
        return (-1) >> 16;
    }

    function logicalRightShift() {
        return (-1) >>> 16;
    }

    function countLeadingZeros() {
        return clz32(42);
    }

    function countLeadingZerosOfZero() {
        return clz32(0);
    }

    function logicalNotNonZero() {
        return (!42) | 0;
    }

    function logicalNotZero() {
        return (!0) | 0;
    }

    function absoluteNegative() {
        return abs(-42);
    }

    function absolutePositive() {
        return abs(42);
    }

    return {
        negate: negate,
        addSubtract: addSubtract,
        addOverflow: addOverflow,
        multiply: multiply,
        multiplyOverflow: multiplyOverflow,
        divide: divide,
        divideByZero: divideByZero,
        divideOverflow: divideOverflow,
        unsignedDivide: unsignedDivide,
        unsignedDivideByZero: unsignedDivideByZero,
        modulo: modulo,
        moduloNegative: moduloNegative,
        moduloZero: moduloZero,
        moduloOverflow: moduloOverflow,
        unsignedModulo: unsignedModulo,
        unsignedModuloZero: unsignedModuloZero,
        bitNot: bitNot,
        bitOr: bitOr,
        bitAnd: bitAnd,
        bitXor: bitXor,
        leftShift: leftShift,
        arithmeticRightShift: arithmeticRightShift,
        logicalRightShift: logicalRightShift,
        countLeadingZeros: countLeadingZeros,
        countLeadingZerosOfZero: countLeadingZerosOfZero,
        logicalNotNonZero: logicalNotNonZero,
        logicalNotZero: logicalNotZero,
        absoluteNegative: absoluteNegative,
        absolutePositive: absolutePositive,
    };
}
*/

var module = loadWebAssembly("wasm/arithmetic.wasm");

shouldBe(module.negate(), -42);

shouldBe(module.addSubtract(), 42);

shouldBe(module.addOverflow(), -2147483648);

shouldBe(module.multiply(), 42);

shouldBe(module.multiplyOverflow(), -2147483648);

shouldBe(module.divide(), 8);

shouldThrow(() => {
    module.divideByZero();
}, "Error: Division by zero or division overflow.");

shouldThrow(() => {
    module.divideOverflow();
}, "Error: Division by zero or division overflow.");

shouldBe(module.unsignedDivide(), 2147483647);

shouldThrow(() => {
    module.unsignedDivideByZero();
}, "Error: Division by zero or division overflow.");

shouldBe(module.modulo(), 2);

shouldBe(module.moduloNegative(), -2);

shouldThrow(() => {
    module.moduloZero();
}, "Error: Division by zero or division overflow.");

shouldThrow(() => {
    module.moduloOverflow();
}, "Error: Division by zero or division overflow.");

shouldBe(module.unsignedModulo(), 67295);

shouldThrow(() => {
    module.unsignedModuloZero();
}, "Error: Division by zero or division overflow.");

shouldBe(module.bitNot(), -2);

shouldBe(module.bitOr(), 7);

shouldBe(module.bitAnd(), 1);

shouldBe(module.bitXor(), 6);

shouldBe(module.leftShift(), 65536);

shouldBe(module.arithmeticRightShift(), -1);

shouldBe(module.logicalRightShift(), 65535);

shouldBe(module.countLeadingZeros(), 26);

shouldBe(module.countLeadingZerosOfZero(), 32);

shouldBe(module.logicalNotNonZero(), 0);

shouldBe(module.logicalNotZero(), 1);

shouldBe(module.absoluteNegative(), 42);

shouldBe(module.absolutePositive(), 42);
