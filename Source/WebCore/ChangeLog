2014-02-21  Radu Stavila  <stavila@adobe.com>

        [CSS Regions] Use the named-flow-specific object RenderNamedFlowFragment instead of the generic RenderRegion whenever possible
        https://bugs.webkit.org/show_bug.cgi?id=128599

        Reviewed by Andrei Bucur.

        Use the named flow specific RenderNamedFlowFragment instead of the generic RenderRegion, whenever possible.
        Move named flow specific methods from RenderRegion to RenderNamedFlowFragment.

        No new tests required.

        * dom/Element.cpp:
        (WebCore::Element::renderNamedFlowFragment):
        (WebCore::Element::webkitRegionOverset):
        (WebCore::Element::webkitGetRegionFlowRanges):
        * dom/Element.h:
        * inspector/InspectorCSSAgent.cpp:
        (WebCore::InspectorCSSAgent::buildArrayForRegions):
        * rendering/PaintInfo.h:
        (WebCore::PaintInfo::PaintInfo):
        * rendering/RenderBlock.cpp:
        (WebCore::RenderBlock::paint):
        (WebCore::RenderBlock::paintObject):
        * rendering/RenderBox.cpp:
        (WebCore::RenderBox::paintBoxDecorations):
        (WebCore::RenderBox::pushContentsClip):
        (WebCore::RenderBox::layoutOverflowRectForPropagation):
        * rendering/RenderBox.h:
        * rendering/RenderBoxModelObject.cpp:
        (WebCore::RenderBoxModelObject::paintMaskForTextFillBox):
        (WebCore::RenderBoxModelObject::paintFillLayerExtended):
        * rendering/RenderBoxModelObject.h:
        * rendering/RenderInline.h:
        * rendering/RenderLayer.cpp:
        (WebCore::RenderLayer::paint):
        (WebCore::RenderLayer::paintLayer):
        (WebCore::RenderLayer::paintLayerContents):
        (WebCore::RenderLayer::paintLayerByApplyingTransform):
        (WebCore::RenderLayer::updatePaintingInfoForFragments):
        (WebCore::RenderLayer::paintTransformedLayerIntoFragments):
        (WebCore::RenderLayer::paintBackgroundForFragments):
        (WebCore::RenderLayer::paintForegroundForFragmentsWithPhase):
        (WebCore::RenderLayer::paintOutlineForFragments):
        (WebCore::RenderLayer::paintMaskForFragments):
        (WebCore::RenderLayer::mapLayerClipRectsToFragmentationLayer):
        (WebCore::RenderLayer::calculateClipRects):
        * rendering/RenderLayer.h:
        * rendering/RenderNamedFlowFragment.cpp:
        (WebCore::RenderNamedFlowFragment::getRanges):
        * rendering/RenderNamedFlowFragment.h:
        * rendering/RenderNamedFlowThread.cpp:
        (WebCore::RenderNamedFlowThread::updateWritingMode):
        (WebCore::compareRenderNamedFlowFragments):
        (WebCore::addFragmentToList):
        (WebCore::RenderNamedFlowThread::addFragmentToNamedFlowThread):
        (WebCore::RenderNamedFlowThread::addRegionToThread):
        (WebCore::RenderNamedFlowThread::removeRegionFromThread):
        (WebCore::RenderNamedFlowThread::computeOversetStateForRegions):
        (WebCore::RenderNamedFlowThread::checkInvalidRegions):
        (WebCore::RenderNamedFlowThread::getRanges):
        (WebCore::RenderNamedFlowThread::checkRegionsWithStyling):
        (WebCore::RenderNamedFlowThread::clearRenderObjectCustomStyle):
        * rendering/RenderNamedFlowThread.h:
        * rendering/RenderRegion.cpp:
        * rendering/RenderRegion.h:
        * rendering/RenderReplaced.cpp:
        (WebCore::RenderReplaced::shouldPaint):
        * rendering/RenderReplica.cpp:
        (WebCore::RenderReplica::paint):
        * rendering/RootInlineBox.cpp:
        (WebCore::RootInlineBox::paint):
        * rendering/svg/RenderSVGRoot.cpp:
        (WebCore::RenderSVGRoot::paintReplaced):

2014-02-21  Andrei Bucur  <abucur@adobe.com>

        [CSS Regions] Regions don't paint correctly in new-multicol elements
        https://bugs.webkit.org/show_bug.cgi?id=120711

        Reviewed by David Hyatt.

        This patch implements basic support for regions inside multi-column elements.
        Currently, the painting and hit-testing logic of CSS Regions is not aware of
        enclosing multi-column elements. The change is integrated at a layer level by
        making use of the pre-computed layer fragments during the painting and hit-testing
        phases for regions.

        There are limitations such that self painting layers found inside the named flow
        thread layer will not be correctly processed because they don't go through the
        layer fragment collection step. This is not trivial to implement because the enclosing
        pagination layer provided by the multi-column element is not visibile from inside
        the named flow thread layer and they reside in different coordinate systems.

        A side effect of this patch is the fix of regions incorrect clipping in certain
        cases (when both a region and its container clip their overflow, the region's
        content is visible outside the container).

        Tests: fast/regions/region-clipping.html
               fast/regions/regions-in-multicol-bt.html
               fast/regions/regions-in-multicol-hover-overflow.html
               fast/regions/regions-in-multicol-hover.html
               fast/regions/regions-in-multicol-lr.html
               fast/regions/regions-in-multicol-rl.html
               fast/regions/regions-in-multicol.html

        * rendering/RenderLayer.cpp:
        (WebCore::RenderLayer::paintLayerContents):
        (WebCore::RenderLayer::hitTestLayer):
        (WebCore::RenderLayer::paintFlowThreadIfRegionForFragments):
        (WebCore::RenderLayer::hitTestFlowThreadIfRegionForFragments):
        * rendering/RenderLayer.h:

2014-02-21  Mihai Tica  <mitica@adobe.com>

        [CSS Blending] Refactor -webkit-blend-mode to -webkit-mix-blend-mode
        https://bugs.webkit.org/show_bug.cgi?id=128805

        Reviewed by Dean Jackson.

        The spec defines the mix-blend-mode property. This means that the
        prefixed version should be -webkit-mix-blend-mode, instead of
        -webkit-blend-mode.

        * css/CSSComputedStyleDeclaration.cpp:
        (WebCore::ComputedStyleExtractor::propertyValue):
        * css/CSSParser.cpp:
        (WebCore::isValidKeywordPropertyAndValue):
        (WebCore::isKeywordPropertyID):
        (WebCore::CSSParser::parseValue):
        * css/CSSPropertyNames.in:
        * css/DeprecatedStyleBuilder.cpp:
        (WebCore::DeprecatedStyleBuilder::DeprecatedStyleBuilder):

2014-02-21  Ryosuke Niwa  <rniwa@webkit.org>

        Bindings tests rebaseline after r164473.

        * bindings/scripts/test/ObjC/DOMTestObj.mm:
        (-[DOMTestObj mutablePoint]):
        (-[DOMTestObj immutablePoint]):
        (-[DOMTestObj mutablePointFunction]):
        (-[DOMTestObj immutablePointFunction]):
        * bindings/scripts/test/ObjC/DOMTestTypedefs.mm:
        (-[DOMTestTypedefs immutablePointFunction]):

2014-02-21  Tim Horton  <timothy_horton@apple.com>

        Remove removed symbol from exports list.

        * WebCore.exp.in:

2014-02-20  ChangSeok Oh  <changseok.oh@collabora.com>

        Rename EXT_draw_buffers to WEBGL_draw_buffers
        https://bugs.webkit.org/show_bug.cgi?id=128894

        Reviewed by Dean Jackson.

        I noticed the related spec has changed. Accordingly chromium also changed its implementation
        to meet the spec. So here I'd like to apply it to webkit as well.

        Merged from Blink (patch by bajones):
        https://src.chromium.org/viewvc/blink?revision=152065&view=revision

        Test: fast/canvas/webgl/webgl-draw-buffers.html

        * CMakeLists.txt:
        * DerivedSources.cpp:
        * DerivedSources.make:
        * GNUmakefile.list.am:
        * WebCore.vcxproj/WebCore.vcxproj:
        * WebCore.vcxproj/WebCore.vcxproj.filters:
        * WebCore.xcodeproj/project.pbxproj:
        * bindings/js/JSWebGLRenderingContextCustom.cpp:
        (WebCore::toJS):
        * html/canvas/EXTDrawBuffers.idl: Removed.
        * html/canvas/WebGLDrawBuffers.cpp: Renamed from Source/WebCore/html/canvas/EXTDrawBuffers.cpp.
        (WebCore::WebGLDrawBuffers::WebGLDrawBuffers):
        (WebCore::WebGLDrawBuffers::~WebGLDrawBuffers):
        (WebCore::WebGLDrawBuffers::getName):
        (WebCore::WebGLDrawBuffers::create):
        (WebCore::WebGLDrawBuffers::supported):
        (WebCore::WebGLDrawBuffers::drawBuffersWEBGL):
        (WebCore::WebGLDrawBuffers::satisfiesWebGLRequirements):
        * html/canvas/WebGLDrawBuffers.h: Renamed from Source/WebCore/html/canvas/EXTDrawBuffers.h.
        * html/canvas/WebGLDrawBuffers.idl: Added.
        * html/canvas/WebGLExtension.h:
        * html/canvas/WebGLFramebuffer.cpp:
        (WebCore::WebGLFramebuffer::drawBuffersIfNecessary):
        * html/canvas/WebGLRenderingContext.cpp:
        (WebCore::WebGLRenderingContext::getExtension):
        (WebCore::WebGLRenderingContext::getParameter):
        (WebCore::WebGLRenderingContext::getSupportedExtensions):
        (WebCore::WebGLRenderingContext::validateFramebufferFuncParameters):
        (WebCore::WebGLRenderingContext::supportsDrawBuffers):
        * html/canvas/WebGLRenderingContext.h:

2014-02-20  Ryosuke Niwa  <rniwa@webkit.org>

        m_ancestorDisabledState should never be unknown
        https://bugs.webkit.org/show_bug.cgi?id=129084

        Reviewed by Benjamin Poulain.

        In order to resolve the bug 129035, a text form control elements needs to synchronously change
        its inner text element's editability by setting or unsetting contenteditable content attribute.
        Before this patch, we could not do this because editability of a text form control dependent on
        its disabled-ness which was only computed lazily via updateAncestorDisabledState().

        This patch makes HTMLFieldSetElement and HTMLFormControlElement update this state synchronously.
        To avoid O(k) DOM traversal, where k is the depth of the tree, in insertedInto and removedFrom of
        HTMLFormControlElement on most pages, a new document-level flag, m_disabledFieldsetElementsCount,
        has been added to indicate whether the document contains any disabled fieldset or not.

        Also renamed the misleadingly named disabledAttributeChanged to disabledStateChanged, and added
        new function of the same name (disabledAttributeChanged) to be used by HTMLFieldSetElement
        for keeping the document-level flag up-to-date upon disabled attribute changes.

        Tests: fast/forms/fieldset/fieldset-disabled-2.html

        * dom/Document.cpp:
        (WebCore::Document::Document): Initializes newly added m_disabledFieldsetElementsCount.
        (WebCore::Document::~Document): Assert that we've done house keeping right.
        * dom/Document.h:
        (WebCore::Document::hasDisabledFieldsetElement): Added.
        (WebCore::Document::addDisabledFieldsetElement): Added.
        (WebCore::Document::removeDisabledFieldsetElement): Added.

        * html/HTMLFieldSetElement.cpp:
        (WebCore::HTMLFieldSetElement::~HTMLFieldSetElement): Removes itself from the owner document.

        (WebCore::updateFromControlElementsAncestorDisabledStateUnder): Added. Updates startNode and
        its descendants' ancestor disabled flag. We don't update controls under another disabled
        fieldset element since disabled-ness of those controls aren't affected by startNode.

        (WebCore::HTMLFieldSetElement::disabledAttributeChanged): Call addDisabledFieldsetElement and
        removeDisabledFieldsetElement to update the owner document's flag.

        (WebCore::HTMLFieldSetElement::disabledStateChanged): Renamed from disabledAttributeChanged. 
        Enable form control elements under the first legend element and disable or enable other
        descendent form controls in accordance with the presence of disabled content attribute.

        (WebCore::HTMLFieldSetElement::childrenChanged): Update disabled-ness of form controls under
        child legend elements because controls aren't disabled in the first legend element, and adding
        or removing child elements may have changed the first legend element.

        (WebCore::HTMLFieldSetElement::didMoveToNewDocument): Update the flag on the owner document.
        * html/HTMLFieldSetElement.h:

        * html/HTMLFormControlElement.cpp:
        (WebCore::HTMLFormControlElement::HTMLFormControlElement):
        (WebCore::HTMLFormControlElement::computeIsDisabledByFieldsetAncestor): Returns boolean instead of
        updating m_ancestorDisabledState internally. Also renamed from updateAncestorDisabledState.

        (WebCore::HTMLFormControlElement::setAncestorDisabled): Replaced ancestorDisabledStateWasChanged.
        This function updates m_disabledByAncestorFieldset and calls disabledAttributeChanged as needed.

        (WebCore::HTMLFormControlElement::disabledAttributeChanged): Added. Calls disabledStateChanged.
        (WebCore::HTMLFormControlElement::disabledStateChanged): Renamed from disabledAttributeChanged.

        (WebCore::HTMLFormControlElement::insertedInto): Update m_disabledByAncestorFieldset if there is
        a possibility (i.e. the document contains any disabled fieldset element) that this form control
        is inserted under a disabled fieldset element.

        (WebCore::HTMLFormControlElement::removedFrom): If this form control element is not disabled by
        a fieldset ancestor, then there is nothing to do. If it is, then check to see if the element is
        still disabled now that we've lost some ancestors.

        (WebCore::HTMLFormControlElement::isDisabledFormControl): No longer updates m_ancestorDisabledState
        lazily since m_disabledByAncestorFieldset is never ambiguous now.

        * html/HTMLFormControlElement.h:
        (WebCore::HTMLFormControlElement::disabledByAncestorFieldset): Added.

2014-02-20  Zalan Bujtas  <zalan@apple.com>

        Remove redundant deviceScaleFactor() functions and make callers use Document::deviceScaleFactor() when accessible.
        https://bugs.webkit.org/show_bug.cgi?id=129137

        Reviewed by Simon Fraser.

        No change in behavior.

        * editing/DeleteButtonController.cpp:
        (WebCore::DeleteButtonController::createDeletionUI):
        * page/Page.cpp:
        * page/Page.h:
        * platform/graphics/GraphicsContext.cpp:
        (WebCore::GraphicsContext::GraphicsContext):
        * platform/graphics/GraphicsContext.h:
        * platform/graphics/cg/GraphicsContextCG.cpp:
        (WebCore::GraphicsContext::platformInit):
        * rendering/RenderBoxModelObject.cpp:
        (WebCore::RenderBoxModelObject::paintFillLayerExtended):
        (WebCore::RenderBoxModelObject::drawBoxSideFromPath):
        * rendering/RenderImage.cpp:
        (WebCore::RenderImage::imageSizeForError):
        (WebCore::RenderImage::paintReplaced):
        * rendering/RenderLayer.cpp:
        (WebCore::RenderLayer::drawPlatformResizerImage):
        * rendering/RenderObject.cpp:
        (WebCore::RenderObject::drawLineForBoxSide):
        * rendering/RenderThemeMac.mm:
        (WebCore::RenderThemeMac::paintProgressBar):
        * rendering/svg/SVGRenderingContext.cpp:
        (WebCore::SVGRenderingContext::calculateTransformationToOutermostCoordinateSystem):

2014-02-20  David Kilzer  <ddkilzer@apple.com>

        Stop generating Objective-C bindings for the SVG DOM
        <http://webkit.org/b/129107>

        Reviewed by Timothy Hatcher.

        Bug 114076 stopped compiling the Objective-C bindings for the
        SVG DOM, but we continued to generate the header and source
        files after that landed in r147822.  This patch also stops
        generating the unused header and source files.

        * DerivedSources.make:
        - Split BINDING_IDLS into NON_SVG_BINDING_IDLS and
          SVG_BINDING_IDLS so that they may operated on separately.
        - Define BINDING_IDLS again as the full list of IDL files.
        - Rename DOM_CLASSES to JS_DOM_CLASSES so that JavaScript
          bindings are still generated for all IDL files.
        - Add OBJC_DOM_CLASSES so that Objective-C bindings are only
          generated for non-SVG IDL files.

        * bindings/scripts/CodeGeneratorObjC.pm:
        (GetBaseClass):
        (GetPropertyAttributes):
        (AddIncludesForType):
        (GenerateHeader):
        (GenerateImplementation):
        - Remove support for SVG classes.

2014-02-20  Simon Fraser  <simon.fraser@apple.com>

        RenderBox::updateShapeOutsideInfoAfterStyleChange shows up on profiles
        https://bugs.webkit.org/show_bug.cgi?id=129075

        Reviewed by Dean Jackson.

        updateShapeOutsideInfoAfterStyleChange() showed up on profiles in content
        with no shapes. Avoid calling this if no style has shapeOutside().

        * rendering/RenderBox.cpp:
        (WebCore::RenderBox::styleDidChange):

2014-02-20  ChangSeok Oh  <changseok.oh@collabora.com>

        Remove unused chromium stuff in Extensions3D
        https://bugs.webkit.org/show_bug.cgi?id=129086

        Reviewed by Anders Carlsson.

        Remove GL_CHROMIUM_copy_texture and GL_CHROMIUM_flipy interfaces since they are used nowhere.

        No new tests since no functionality changed.

        * platform/graphics/Extensions3D.h:
        * platform/graphics/opengl/Extensions3DOpenGL.cpp:
        * platform/graphics/opengl/Extensions3DOpenGL.h:
        * platform/graphics/opengl/Extensions3DOpenGLES.cpp:
        * platform/graphics/opengl/Extensions3DOpenGLES.h:

2014-02-20  Joseph Pecoraro  <pecoraro@apple.com>

        [iOS] Assert / crash trying to draw empty checked input
        https://bugs.webkit.org/show_bug.cgi?id=129138

        Reviewed by Simon Fraser.

        Test: fast/forms/checkbox-empty-size.html

        * rendering/RenderThemeIOS.mm:
        (WebCore::shortened):
        Avoid a divide by 0, but checking for the condition upfront.

2014-02-20  Benjamin Poulain  <bpoulain@apple.com>

        Start fixing the view states driven by the WKScrollView
        https://bugs.webkit.org/show_bug.cgi?id=129140

        Reviewed by Tim Horton and Simon Fraser.

        * platform/graphics/ca/mac/TileController.mm:
        (WebCore::TileController::scaledExposedRect):
        That comment was more confusing than helping. FrameView-relative coordinates should not need
        scaling.

2014-02-20  Gyuyoung Kim  <gyuyoung.kim@samsung.com>

        Start to use std::unique_ptr for DragImageLoader
        https://bugs.webkit.org/show_bug.cgi?id=129078

        Reviewed by Ryosuke Niwa.

        As a step to use std::unique_ptr, this patch replace uses of OwnPtr and PassOwnPtr
        in the DragImageLoader class with std::unique_ptr. Besides DragImageLoader is set to
        non-copyable class.

        * dom/Clipboard.cpp:
        (WebCore::Clipboard::setDragImage):
        * dom/Clipboard.h:

2014-02-20  Brady Eidson  <beidson@apple.com>

        Move the image controls setting to Settings.in
        https://bugs.webkit.org/show_bug.cgi?id=129126

        Reviewed by Tim Horton.

        * page/Settings.cpp:
        (WebCore::Settings::Settings):
        * page/Settings.h:
        * page/Settings.in:

2014-02-20  Brady Eidson  <beidson@apple.com>

        Add very basic image control rendering
        https://bugs.webkit.org/show_bug.cgi?id=129080

        Reviewed by Tim Horton.

        Test: fast/images/image-controls-basic.html

        This patch is groundwork that adds a very basic image control that can render on top of images.

        * dom/Node.h:
        (WebCore::Node:: isImageControlsRootElement): Returns false, unless you are an ImageControls object.
        * html/HTMLAttributeNames.in:

        Teach HTMLImageElement how to understand an experimental attribute to install controls,
        how to actually build the DOM to attach to the shadow root, how to tear that DOM down,
        and how to make sure that Renderers are created for that DOM:
        * html/HTMLImageElement.cpp:
        (WebCore::HTMLImageElement::HTMLImageElement):
        (WebCore::HTMLImageElement::parseAttribute):
        (WebCore::HTMLImageElement::didAttachRenderers):
        (WebCore::HTMLImageElement::updateImageControls):
        (WebCore::HTMLImageElement::createImageControls):
        (WebCore::HTMLImageElement::destroyImageControls):
        (WebCore::HTMLImageElement::hasImageControls):
        (WebCore::HTMLImageElement::childShouldCreateRenderer):
        * html/HTMLImageElement.h:
        (WebCore::HTMLImageElement::hasShadowControls): For RenderImage to query when it is constructed. 

        Add a generic, platform independent ImageControls root element that does nothing:
        * html/shadow/ImageControlsRootElement.cpp: Added.
        (WebCore::ImageControlsRootElement::maybeCreate):
        (WebCore::ImageControlsRootElement::ImageControlsRootElement):
        (WebCore::ImageControlsRootElement::~ImageControlsRootElement):
        * html/shadow/ImageControlsRootElement.h: Added.

        Add a Mac-specific ImageControls root element that renders a 20x20 red box (for now):
        * html/shadow/mac/ImageControlsRootElementMac.cpp: Added.
        (WebCore::ImageControlsRootElementMac::ImageControlsRootElementMac):
        (WebCore::ImageControlsRootElementMac::~ImageControlsRootElementMac):
        (WebCore::ImageControlsRootElement::maybeCreate):
        (WebCore::ImageControlsRootElementMac::maybeCreate):
        * html/shadow/mac/ImageControlsRootElementMac.h: Added.

        Since much of the RenderMedia::layout() method is now required for RenderImage as well,
        move the logic to RenderImage. The extra work is controlled by a bool flag that will always
        be set for RenderMedias but will only be set for certain RenderImages:
        * rendering/RenderImage.cpp:
        (WebCore::RenderImage::RenderImage):
        (WebCore::RenderImage::canHaveChildren):
        (WebCore::RenderImage::layout):
        (WebCore::RenderImage::layoutShadowControls):
        * rendering/RenderImage.h:
        (WebCore::RenderImage::setHasShadowControls):
        (WebCore::RenderImage::shadowControlsNeedCustomLayoutMetrics):

        * rendering/RenderMedia.cpp:
        (WebCore::RenderMedia::RenderMedia):
        * rendering/RenderMedia.h:
        (WebCore::RenderMedia::shadowControlsNeedCustomLayoutMetrics):

        * WebCore.xcodeproj/project.pbxproj:

== Rolled over to ChangeLog-2014-02-20 ==
