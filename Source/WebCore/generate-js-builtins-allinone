#!/usr/bin/python
# Copyright (C) 2015 Canon Inc. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
# OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


import argparse
import filecmp
import os
import re

singleLineCommentRegExp = re.compile(r"\/\/ @.*?\n", re.MULTILINE | re.S)

def retrieveGenerationParameters(input):
    parameters = {}
    with open(input, 'r') as input_file:
        content = input_file.read()
        for match in singleLineCommentRegExp.finditer(content):
            values = content[match.start() + 4:match.end()].split('=')
            if len(values) == 1:
                parameters[values[0].strip()] = True
            elif len (values) == 2:
                parameters[values[0].strip()] = values[1].strip()
            else:
                print("Skipping potential generation parameter directive:" % values.join('='))
    return parameters


def retrieveFilesWithParameters(inputs):
    files = []
    class FileInput: pass
    for input in inputs:
        file_input = FileInput()
        file_input.parameters = retrieveGenerationParameters(input)
        file_input.optionalif = ("#if ENABLE(" + file_input.parameters["optional"] + ")\n") if "optional" in file_input.parameters else ""
        file_input.optionalendif = "#endif\n" if "optional" in file_input.parameters else ""
        file_input.filename = os.path.splitext(os.path.basename(input))[0]
        file_input.name = file_input.filename[0].lower() + file_input.filename[1:]
        files.append(file_input)
    return files


def writeConditional(writer, input_file, value):
    writer.write(input_file.optionalif)
    writer.write(value)
    writer.write(input_file.optionalendif)


parser = argparse.ArgumentParser()
parser.add_argument('--output_dir', default='', help='output directory')
parser.add_argument('inputs', metavar='input', nargs='+', help='path to input JS files')

args = parser.parse_args()
files = retrieveFilesWithParameters(args.inputs)
internals_files = [ f for f in files if "internals" in f.parameters ]

basename = "WebCoreJSBuiltins"
output_base = os.path.join(args.output_dir, basename)
private_output_base = os.path.join(args.output_dir, "Private" + basename)


# Create writers
builtinsHeader = open(output_base + ".h.tmp", "w")
builtinsImplementation = open(output_base + ".cpp.tmp", "w")
privateBuiltinsHeader = open(private_output_base + ".h.tmp", "w")

preamble = """
/* Generated by generate-js-builtins-allinone do not hand edit. */

/*
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 2 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library; if not, write to the Free Software
 *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */

"""

###############
# Generation of cpp file including all JS builtin generated cpp files with optional #fdef directives as defined by @enable in JS files.
###############
builtinsImplementation.write(preamble)
builtinsImplementation.write("#include \"config.h\"\n\n")

# Including cpp files
for input_file in files:
    writeConditional(builtinsImplementation, input_file, "#include \"" + input_file.filename + "Builtins.cpp\"\n");

builtinsImplementation.close()

###############
# Generation of wrapper header file defining access to all builtin functions.
###############
builtinsHeader.write(preamble)
builtinsHeader.write("#ifndef " + basename + "_h\n#define " + basename + "_h\n\n")

for input_file in files:
    writeConditional(builtinsHeader, input_file, "#include \"" + input_file.filename + "BuiltinsWrapper.h\"\n");
builtinsHeader.write("""

#include <runtime/VM.h>

namespace WebCore {

class JSBuiltinFunctions {
public:
""")

# Constructor
builtinsHeader.write("    explicit JSBuiltinFunctions(JSC::VM& v)\n        : vm(v)\n");
for input_file in files:
    writeConditional(builtinsHeader, input_file, "        , m_" + input_file.name + "Builtins(&vm)\n");
builtinsHeader.write("    {\n");
for input_file in internals_files:
    writeConditional(builtinsHeader, input_file, "        m_" + input_file.name + "Builtins.exportNames();\n");
builtinsHeader.write("    }\n");

# Getters
for input_file in files:
    writeConditional(builtinsHeader, input_file, "    " + input_file.filename + "BuiltinsWrapper& " + input_file.name  + "Builtins() { return m_" + input_file.name  + "Builtins;}\n");

# Declarations
builtinsHeader.write("""private:
    JSC::VM& vm;\n""");
for input_file in files:
    writeConditional(builtinsHeader, input_file, "    " + input_file.filename + "BuiltinsWrapper m_" + input_file.name  + "Builtins;\n");

builtinsHeader.write("""
};

}

#endif
""");

builtinsHeader.close()

###############
# Generation of class wrapping all functions of JS files marked as @internals.
###############
privateBuiltinsHeader.write(preamble)
privateBuiltinsHeader.write("#ifndef Private" + basename + "_h\n#define Private" + basename + "_h\n\n")

# Including all necessrary wrapper headers.
for input_file in internals_files:
    writeConditional(privateBuiltinsHeader, input_file, "#include \"" + input_file.filename + "BuiltinsWrapper.h\"\n")

# Class definition
privateBuiltinsHeader.write("""
namespace WebCore {

class JSBuiltinInternalFunctions {
public:
""")

# Constructor
privateBuiltinsHeader.write("""explicit JSBuiltinInternalFunctions(JSC::VM& v)\n        : vm(v)\n""")
for input_file in internals_files:
    writeConditional(privateBuiltinsHeader, input_file, "        , m_" + input_file.name + "Functions(vm)\n")
privateBuiltinsHeader.write("    { }\n\n")

# Getters
for input_file in internals_files:
    writeConditional(privateBuiltinsHeader, input_file, "    " + input_file.filename + "BuiltinFunctions " + input_file.name + "() { return m_" + input_file.name + "Functions; }\n")

# Visitor wrapper routine
privateBuiltinsHeader.write("    void visit(JSC::SlotVisitor& visitor) {\n")
for input_file in internals_files:
    writeConditional(privateBuiltinsHeader, input_file, "        m_" + input_file.name + "Functions.visit(visitor);\n")
privateBuiltinsHeader.write("    }\n")

# Init wrapper routine
privateBuiltinsHeader.write("    void init(JSC::JSGlobalObject& globalObject) {\n")
for input_file in internals_files:
    writeConditional(privateBuiltinsHeader, input_file, "        m_" + input_file.name + "Functions.init(globalObject);\n")
privateBuiltinsHeader.write("    }\n")

# Private member fields
privateBuiltinsHeader.write("""
private:
    JSC::VM& vm;\n""")
for input_file in internals_files:
    writeConditional(privateBuiltinsHeader, input_file, "     " + input_file.filename + "BuiltinFunctions m_" + input_file.name + "Functions;\n")

privateBuiltinsHeader.write("""
};

}
#endif
""")

privateBuiltinsHeader.close()

def copytempfile(output):
    if (not os.path.exists(output)) or (not filecmp.cmp(output + ".tmp", output, shallow=False)):
        if (os.path.exists(output)):
            os.remove(output)
        os.rename(output + ".tmp", output)
    else:
        os.remove(output + ".tmp")

copytempfile(output_base + ".h")
copytempfile(output_base + ".cpp")
copytempfile(private_output_base + ".h")
