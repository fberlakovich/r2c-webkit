From 38a838284552711d6228db9bab2dec728402098d Mon Sep 17 00:00:00 2001
From: Youenn Fablet <youenn@apple.com>
Date: Mon, 8 Oct 2018 10:38:12 -0700
Subject: [PATCH 1/2] libwebrtc changes

---
 .../audio_codecs/ilbc/audio_encoder_ilbc.cc   |   2 +-
 .../libwebrtc/Source/webrtc/api/mediatypes.cc |   4 +-
 .../Source/webrtc/audio/remix_resample.cc     |   4 +-
 .../Source/webrtc/common_audio/wav_file.cc    |   4 +-
 .../webrtc/common_video/video_frame_buffer.cc |   2 +-
 .../modules/audio_coding/acm2/rent_a_codec.cc |   4 +-
 .../codecs/cng/audio_encoder_cng.cc           |   2 +-
 .../codecs/ilbc/audio_encoder_ilbc.cc         |   4 +-
 .../neteq/tools/rtp_file_source.cc            |   2 +-
 .../Source/webrtc/p2p/base/tcpport.cc         |  10 +
 .../libwebrtc/Source/webrtc/pc/bundlefilter.h |   2 +-
 .../Source/webrtc/pc/peerconnectionfactory.cc |   4 +-
 .../webrtc/pc/rtpparametersconversion.cc      |   2 +-
 .../libwebrtc/Source/webrtc/rtc_base/checks.h |   6 +-
 .../libwebrtc/Source/webrtc/rtc_base/flags.cc |   6 +-
 .../Source/webrtc/rtc_base/location.h         |   2 +-
 .../Source/webrtc/rtc_base/logging.cc         |  54 ++-
 .../webrtc/rtc_base/logging_unittest.cc       |   2 +-
 .../Source/webrtc/rtc_base/never_destroyed.h  |  69 ++++
 .../rtc_base/numerics/safe_conversions.h      |   4 +-
 .../webrtc/rtc_base/opensslcertificate.cc     |   8 +-
 .../Source/webrtc/rtc_base/stringize_macros.h |   4 +-
 .../webrtc/rtc_base/virtualsocketserver.cc    |   3 +-
 .../PeerConnection/RTCH264ProfileLevelId.mm   |  58 +++
 .../peerconnection/RTCEncodedImage+Private.mm |   4 +-
 .../peerconnection/RTCRtpEncodingParameters.h |   1 +
 .../RTCVideoEncoderSettings+Private.h         |   7 +
 .../RTCVideoEncoderSettings+Private.mm        |  52 ++-
 .../api/video_codec/RTCVideoCodecConstants.mm |   4 +-
 .../objc/api/video_codec/RTCVideoEncoderVP8.h |   1 +
 .../RTCWrappedNativeVideoEncoder.mm           |   5 +
 .../video_frame_buffer/RTCNativeI420Buffer.h  |   1 +
 .../RTCNativeMutableI420Buffer.h              |   1 +
 .../sdk/objc/base/RTCCodecSpecificInfo.h      |   1 +
 .../webrtc/sdk/objc/base/RTCEncodedImage.h    |   2 +
 .../webrtc/sdk/objc/base/RTCEncodedImage.m    |   1 +
 .../webrtc/sdk/objc/base/RTCI420Buffer.h      |   1 +
 .../sdk/objc/base/RTCRtpFragmentationHeader.h |   1 +
 .../sdk/objc/base/RTCRtpFragmentationHeader.m |   3 +-
 .../webrtc/sdk/objc/base/RTCVideoCodecInfo.h  |   1 +
 .../webrtc/sdk/objc/base/RTCVideoDecoder.h    |   1 +
 .../sdk/objc/base/RTCVideoDecoderFactory.h    |   1 +
 .../webrtc/sdk/objc/base/RTCVideoEncoder.h    |   8 +-
 .../sdk/objc/base/RTCVideoEncoderFactory.h    |   1 +
 .../objc/base/RTCVideoEncoderQpThresholds.h   |   1 +
 .../sdk/objc/base/RTCVideoEncoderSettings.h   |   6 +
 .../webrtc/sdk/objc/base/RTCVideoFrame.h      |   1 +
 .../sdk/objc/base/RTCVideoFrameBuffer.h       |   1 +
 .../video_codec/RTCCodecSpecificInfoH264.h    |   3 +-
 .../RTCDefaultVideoDecoderFactory.h           |   1 +
 .../RTCDefaultVideoEncoderFactory.h           |   1 +
 .../video_codec/RTCH264ProfileLevelId.h       |   1 +
 .../video_codec/RTCH264ProfileLevelId.mm      |  16 +-
 .../video_codec/RTCVideoDecoderFactoryH264.h  |   1 +
 .../video_codec/RTCVideoDecoderH264.h         |   1 +
 .../video_codec/RTCVideoEncoderFactoryH264.h  |   1 +
 .../video_codec/RTCVideoEncoderH264.h         |   1 +
 .../video_codec/RTCVideoEncoderH264.mm        | 382 ++++++++++++++----
 .../objc/components/video_codec/helpers.cc    |  16 +-
 .../sdk/objc/components/video_codec/helpers.h |  10 +-
 .../video_frame_buffer/RTCCVPixelBuffer.h     |   1 +
 .../native/src/objc_video_encoder_factory.mm  |   6 +
 62 files changed, 637 insertions(+), 172 deletions(-)
 create mode 100644 Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/never_destroyed.h
 create mode 100644 Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Classes/PeerConnection/RTCH264ProfileLevelId.mm

diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/api/audio_codecs/ilbc/audio_encoder_ilbc.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/api/audio_codecs/ilbc/audio_encoder_ilbc.cc
index efcef382ff7..2ae75474ccd 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/api/audio_codecs/ilbc/audio_encoder_ilbc.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/api/audio_codecs/ilbc/audio_encoder_ilbc.cc
@@ -33,7 +33,7 @@ int GetIlbcBitrate(int ptime) {
       // 50 bytes per frame of 30 ms => (approx) 13333 bits/s.
       return 13333;
     default:
-      FATAL();
+      RTC_FATAL();
   }
 }
 }  // namespace
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/api/mediatypes.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/api/mediatypes.cc
index 599542db08f..140d0ae9625 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/api/mediatypes.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/api/mediatypes.cc
@@ -28,7 +28,7 @@ std::string MediaTypeToString(MediaType type) {
     case MEDIA_TYPE_DATA:
       return kMediaTypeData;
   }
-  FATAL();
+  RTC_FATAL();
   // Not reachable; avoids compile warning.
   return "";
 }
@@ -41,7 +41,7 @@ MediaType MediaTypeFromString(const std::string& type_str) {
   } else if (type_str == kMediaTypeData) {
     return MEDIA_TYPE_DATA;
   }
-  FATAL();
+  RTC_FATAL();
   // Not reachable; avoids compile warning.
   return static_cast<MediaType>(-1);
 }
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/audio/remix_resample.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/audio/remix_resample.cc
index eda70c7c378..97222e947a4 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/audio/remix_resample.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/audio/remix_resample.cc
@@ -58,7 +58,7 @@ void RemixAndResample(const int16_t* src_data,
 
   if (resampler->InitializeIfNeeded(sample_rate_hz, dst_frame->sample_rate_hz_,
                                     audio_ptr_num_channels) == -1) {
-    FATAL() << "InitializeIfNeeded failed: sample_rate_hz = " << sample_rate_hz
+    RTC_FATAL() << "InitializeIfNeeded failed: sample_rate_hz = " << sample_rate_hz
             << ", dst_frame->sample_rate_hz_ = " << dst_frame->sample_rate_hz_
             << ", audio_ptr_num_channels = " << audio_ptr_num_channels;
   }
@@ -72,7 +72,7 @@ void RemixAndResample(const int16_t* src_data,
       resampler->Resample(audio_ptr, src_length, dst_frame->mutable_data(),
                           AudioFrame::kMaxDataSizeSamples);
   if (out_length == -1) {
-    FATAL() << "Resample failed: audio_ptr = " << audio_ptr
+    RTC_FATAL() << "Resample failed: audio_ptr = " << audio_ptr
             << ", src_length = " << src_length
             << ", dst_frame->mutable_data() = " << dst_frame->mutable_data();
   }
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/common_audio/wav_file.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/common_audio/wav_file.cc
index 008891f9cfb..0209f52d2c7 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/common_audio/wav_file.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/common_audio/wav_file.cc
@@ -53,7 +53,7 @@ WavReader::WavReader(rtc::PlatformFile file) {
     if (!rtc::ClosePlatformFile(file)) {
       RTC_LOG(LS_ERROR) << "Can't close file.";
     }
-    FATAL() << "Could not open wav file for reading.";
+    RTC_FATAL() << "Could not open wav file for reading.";
   }
 
   ReadableWavFile readable(file_handle_);
@@ -138,7 +138,7 @@ WavWriter::WavWriter(rtc::PlatformFile file,
     if (!rtc::ClosePlatformFile(file)) {
       RTC_LOG(LS_ERROR) << "Can't close file.";
     }
-    FATAL() << "Could not open wav file for writing.";
+    RTC_FATAL() << "Could not open wav file for writing.";
   }
 
   RTC_CHECK(CheckWavParameters(num_channels_, sample_rate_, kWavFormat,
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/common_video/video_frame_buffer.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/common_video/video_frame_buffer.cc
index 2cd0b290f15..be0b4927bbe 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/common_video/video_frame_buffer.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/common_video/video_frame_buffer.cc
@@ -323,7 +323,7 @@ rtc::scoped_refptr<PlanarYuvBuffer> WrapYuvBuffer(
       return WrapI444Buffer(width, height, y_plane, y_stride, u_plane, u_stride,
                             v_plane, v_stride, no_longer_used);
     default:
-      FATAL() << "Unexpected frame buffer type.";
+      RTC_FATAL() << "Unexpected frame buffer type.";
       return nullptr;
   }
 }
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/acm2/rent_a_codec.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/acm2/rent_a_codec.cc
index 0a9ce117e2b..45d78d74a5d 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/acm2/rent_a_codec.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/acm2/rent_a_codec.cc
@@ -211,7 +211,7 @@ std::unique_ptr<AudioEncoder> CreateCngEncoder(
       config.vad_mode = Vad::kVadVeryAggressive;
       break;
     default:
-      FATAL();
+      RTC_FATAL();
   }
   return std::unique_ptr<AudioEncoder>(new AudioEncoderCng(std::move(config)));
 }
@@ -226,7 +226,7 @@ std::unique_ptr<AudioDecoder> CreateIsacDecoder(
   return std::unique_ptr<AudioDecoder>(
       new AudioDecoderIsacFloatImpl(sample_rate_hz, bwinfo));
 #else
-  FATAL() << "iSAC is not supported.";
+  RTC_FATAL() << "iSAC is not supported.";
   return std::unique_ptr<AudioDecoder>();
 #endif
 }
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/codecs/cng/audio_encoder_cng.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/codecs/cng/audio_encoder_cng.cc
index 4cda3401fa2..055190497a5 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/codecs/cng/audio_encoder_cng.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/codecs/cng/audio_encoder_cng.cc
@@ -139,7 +139,7 @@ AudioEncoder::EncodedInfo AudioEncoderCng::EncodeImpl(
       break;
     }
     case Vad::kError: {
-      FATAL();  // Fails only if fed invalid data.
+      RTC_FATAL();  // Fails only if fed invalid data.
       break;
     }
   }
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/codecs/ilbc/audio_encoder_ilbc.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/codecs/ilbc/audio_encoder_ilbc.cc
index 84695e37630..dae956b30c0 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/codecs/ilbc/audio_encoder_ilbc.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/codecs/ilbc/audio_encoder_ilbc.cc
@@ -40,7 +40,7 @@ int GetIlbcBitrate(int ptime) {
       // 50 bytes per frame of 30 ms => (approx) 13333 bits/s.
       return 13333;
     default:
-      FATAL();
+      RTC_FATAL();
   }
 }
 
@@ -147,7 +147,7 @@ size_t AudioEncoderIlbcImpl::RequiredOutputSizeBytes() const {
     case 6:
       return 2 * 50;
     default:
-      FATAL();
+      RTC_FATAL();
   }
 }
 
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/neteq/tools/rtp_file_source.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/neteq/tools/rtp_file_source.cc
index 806bba7a9fe..7bf7d52083c 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/neteq/tools/rtp_file_source.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/modules/audio_coding/neteq/tools/rtp_file_source.cc
@@ -89,7 +89,7 @@ bool RtpFileSource::OpenFile(const std::string& file_name) {
     return true;
   rtp_reader_.reset(RtpFileReader::Create(RtpFileReader::kPcap, file_name));
   if (!rtp_reader_) {
-    FATAL() << "Couldn't open input file as either a rtpdump or .pcap. Note "
+    RTC_FATAL() << "Couldn't open input file as either a rtpdump or .pcap. Note "
                "that .pcapng is not supported.";
   }
   return true;
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/tcpport.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/tcpport.cc
index d070f6ecee8..c66c7307375 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/tcpport.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/p2p/base/tcpport.cc
@@ -351,11 +351,21 @@ TCPConnection::TCPConnection(TCPPort* port,
                         << ", port() Network:" << port->Network()->ToString();
     const std::vector<rtc::InterfaceAddress>& desired_addresses =
         port_->Network()->GetIPs();
+
+#if defined(WEBRTC_WEBKIT_BUILD)
+     RTC_DCHECK(socket->GetLocalAddress().IsLoopbackIP() ||
+                (std::find_if(desired_addresses.begin(), desired_addresses.end(),
+                             [this](const rtc::InterfaceAddress& addr) {
+                               return socket_->GetLocalAddress().ipaddr() ==
+                                      addr;
+                             }) != desired_addresses.end()));
+ #else
     RTC_DCHECK(std::find_if(desired_addresses.begin(), desired_addresses.end(),
                             [this](const rtc::InterfaceAddress& addr) {
                               return socket_->GetLocalAddress().ipaddr() ==
                                      addr;
                             }) != desired_addresses.end());
+#endif
     ConnectSocketSignals(socket);
   }
 }
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/pc/bundlefilter.h b/Source/ThirdParty/libwebrtc/Source/webrtc/pc/bundlefilter.h
index 7decbba8a4f..de477f457f2 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/pc/bundlefilter.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/pc/bundlefilter.h
@@ -17,7 +17,7 @@
 #include <vector>
 
 #include "media/base/streamparams.h"
-#include "rtc_base/basictypes.h"
+//#include "rtc_base/basictypes.h"
 
 namespace cricket {
 
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/pc/peerconnectionfactory.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/pc/peerconnectionfactory.cc
index b78ed8db1ee..53f4da8516e 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/pc/peerconnectionfactory.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/pc/peerconnectionfactory.cc
@@ -257,7 +257,7 @@ RtpCapabilities PeerConnectionFactory::GetRtpSenderCapabilities(
       return RtpCapabilities();
   }
   // Not reached; avoids compile warning.
-  FATAL();
+  RTC_FATAL();
 }
 
 RtpCapabilities PeerConnectionFactory::GetRtpReceiverCapabilities(
@@ -284,7 +284,7 @@ RtpCapabilities PeerConnectionFactory::GetRtpReceiverCapabilities(
       return RtpCapabilities();
   }
   // Not reached; avoids compile warning.
-  FATAL();
+  RTC_FATAL();
 }
 
 rtc::scoped_refptr<AudioSourceInterface>
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/pc/rtpparametersconversion.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/pc/rtpparametersconversion.cc
index a57066e4db0..e519b9b06de 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/pc/rtpparametersconversion.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/pc/rtpparametersconversion.cc
@@ -61,7 +61,7 @@ RTCErrorOr<cricket::FeedbackParam> ToCricketFeedbackParam(
       return cricket::FeedbackParam(cricket::kRtcpFbParamTransportCc);
   }
   // Not reached; avoids compile warning.
-  FATAL();
+  RTC_FATAL();
 }
 
 template <typename C>
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/checks.h b/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/checks.h
index 9de6d47573c..5cf0679910e 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/checks.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/checks.h
@@ -80,7 +80,7 @@ RTC_NORETURN void rtc_FatalMessage(const char* file, int line, const char* msg);
 //   messages if the condition doesn't hold. Prefer them to raw RTC_CHECK and
 //   RTC_DCHECK.
 //
-// - FATAL() aborts unconditionally.
+// - RTC_FATAL() aborts unconditionally.
 //
 // TODO(ajm): Ideally, checks.h would be combined with logging.h, but
 // consolidation with system_wrappers/logging.h should happen first.
@@ -348,9 +348,9 @@ class FatalLogCall final {
 #define RTC_NOTREACHED() RTC_DCHECK(RTC_UNREACHABLE_CODE_HIT)
 
 // TODO(bugs.webrtc.org/8454): Add an RTC_ prefix or rename differently.
-#define FATAL()                                                    \
+#define RTC_FATAL()                                                    \
   rtc::webrtc_checks_impl::FatalLogCall<false>(__FILE__, __LINE__, \
-                                               "FATAL()") &        \
+                                               "RTC_FATAL()") &        \
       rtc::webrtc_checks_impl::LogStreamer<>()
 
 // Performs the integer division a/b and returns the result. CHECKs that the
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/flags.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/flags.cc
index 5b28794f6ca..4f294594bd4 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/flags.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/flags.cc
@@ -80,7 +80,7 @@ void Flag::SetToDefault() {
       variable_->s = default_.s;
       return;
   }
-  FATAL() << "unreachable code";
+  RTC_FATAL() << "unreachable code";
 }
 
 static const char* Type2String(Flag::Type type) {
@@ -94,7 +94,7 @@ static const char* Type2String(Flag::Type type) {
     case Flag::STRING:
       return "string";
   }
-  FATAL() << "unreachable code";
+  RTC_FATAL() << "unreachable code";
 }
 
 static void PrintFlagValue(Flag::Type type, FlagValue* p) {
@@ -112,7 +112,7 @@ static void PrintFlagValue(Flag::Type type, FlagValue* p) {
       printf("%s", p->s);
       return;
   }
-  FATAL() << "unreachable code";
+  RTC_FATAL() << "unreachable code";
 }
 
 void Flag::Print(bool print_current_value) {
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/location.h b/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/location.h
index 513bc263651..718d9589348 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/location.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/location.h
@@ -50,7 +50,7 @@ class Location {
 #define RTC_FROM_HERE RTC_FROM_HERE_WITH_FUNCTION(__FUNCTION__)
 
 #define RTC_FROM_HERE_WITH_FUNCTION(function_name) \
-  ::rtc::Location(function_name, __FILE__ ":" STRINGIZE(__LINE__))
+  ::rtc::Location(function_name, __FILE__ ":" RTC_STRINGIZE(__LINE__))
 
 }  // namespace rtc
 
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/logging.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/logging.cc
index 129a8974397..58456c599ec 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/logging.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/logging.cc
@@ -36,6 +36,7 @@ static const int kMaxLogLineSize = 1024 - 60;
 #include "rtc_base/criticalsection.h"
 #include "rtc_base/logging.h"
 #include "rtc_base/platform_thread_types.h"
+#include "rtc_base/never_destroyed.h"
 #include "rtc_base/stringencode.h"
 #include "rtc_base/strings/string_builder.h"
 #include "rtc_base/stringutils.h"
@@ -62,8 +63,12 @@ const char* FilenameFromPath(const char* file) {
     return (end1 > end2) ? end1 + 1 : end2 + 1;
 }
 
-// Global lock for log subsystem, only needed to serialize access to streams_.
-CriticalSection g_log_crit;
+// Global lock for log subsystem, only needed to serialize access to streamList().
+CriticalSection& logCriticalScope() {
+  static auto scope = makeNeverDestroyed<>(CriticalSection { });
+  return scope.get();
+}
+
 }  // namespace
 
 // Inefficient default implementation, override is recommended.
@@ -83,7 +88,15 @@ bool LogMessage::log_to_stderr_ = true;
 // Note: we explicitly do not clean this up, because of the uncertain ordering
 // of destructors at program exit.  Let the person who sets the stream trigger
 // cleanup by setting to null, or let it leak (safe at program exit).
-LogMessage::StreamList LogMessage::streams_ RTC_GUARDED_BY(g_log_crit);
+typedef std::pair<LogSink*, LoggingSeverity> StreamAndSeverity;
+typedef std::list<StreamAndSeverity> StreamList;
+
+// The output streams and their associated severities
+StreamList& streamList()
+    RTC_EXCLUSIVE_LOCKS_REQUIRED(logCriticalScope()) {
+        static auto stream_list = makeNeverDestroyed<>(StreamList { });
+  return stream_list.get();
+}
 
 // Boolean options default to false (0)
 bool LogMessage::thread_, LogMessage::timestamp_;
@@ -97,6 +110,10 @@ LogMessage::LogMessage(const char* file,
                        LogErrorContext err_ctx,
                        int err)
     : severity_(sev) {
+
+  static std::once_flag callLogCriticalScopeOnce;
+  std::call_once(callLogCriticalScopeOnce,[] { logCriticalScope(); });
+
   if (timestamp_) {
     // Use SystemTimeMillis so that even if tests use fake clocks, the timestamp
     // in log messages represents the real system time.
@@ -197,8 +214,8 @@ LogMessage::~LogMessage() {
 #endif
   }
 
-  CritScope cs(&g_log_crit);
-  for (auto& kv : streams_) {
+  CritScope cs(&logCriticalScope());
+  for (auto& kv : streamList()) {
     if (severity_ >= kv.second) {
 #if defined(WEBRTC_ANDROID)
       kv.first->OnLogMessage(str, severity_, tag_);
@@ -246,7 +263,7 @@ void LogMessage::LogTimestamps(bool on) {
 
 void LogMessage::LogToDebug(LoggingSeverity min_sev) {
   g_dbg_sev = min_sev;
-  CritScope cs(&g_log_crit);
+  CritScope cs(&logCriticalScope());
   UpdateMinLogSeverity();
 }
 
@@ -255,9 +272,9 @@ void LogMessage::SetLogToStderr(bool log_to_stderr) {
 }
 
 int LogMessage::GetLogToStream(LogSink* stream) {
-  CritScope cs(&g_log_crit);
+  CritScope cs(&logCriticalScope());
   LoggingSeverity sev = LS_NONE;
-  for (auto& kv : streams_) {
+  for (auto& kv : streamList()) {
     if (!stream || stream == kv.first) {
       sev = std::min(sev, kv.second);
     }
@@ -266,16 +283,16 @@ int LogMessage::GetLogToStream(LogSink* stream) {
 }
 
 void LogMessage::AddLogToStream(LogSink* stream, LoggingSeverity min_sev) {
-  CritScope cs(&g_log_crit);
-  streams_.push_back(std::make_pair(stream, min_sev));
+  CritScope cs(&logCriticalScope());
+  streamList().push_back(std::make_pair(stream, min_sev));
   UpdateMinLogSeverity();
 }
 
 void LogMessage::RemoveLogToStream(LogSink* stream) {
-  CritScope cs(&g_log_crit);
-  for (StreamList::iterator it = streams_.begin(); it != streams_.end(); ++it) {
+  CritScope cs(&logCriticalScope());
+  for (StreamList::iterator it = streamList().begin(); it != streamList().end(); ++it) {
     if (stream == it->first) {
-      streams_.erase(it);
+      streamList().erase(it);
       break;
     }
   }
@@ -334,9 +351,9 @@ void LogMessage::ConfigureLogging(const char* params) {
 }
 
 void LogMessage::UpdateMinLogSeverity()
-    RTC_EXCLUSIVE_LOCKS_REQUIRED(g_log_crit) {
+    RTC_EXCLUSIVE_LOCKS_REQUIRED(logCriticalScope()) {
   LoggingSeverity min_sev = g_dbg_sev;
-  for (const auto& kv : streams_) {
+  for (const auto& kv : streamList()) {
     const LoggingSeverity sev = kv.second;
     min_sev = std::min(min_sev, sev);
   }
@@ -450,11 +467,8 @@ bool LogMessage::IsNoop(LoggingSeverity severity) {
   // TODO(tommi): We're grabbing this lock for every LogMessage instance that
   // is going to be logged. This introduces unnecessary synchronization for
   // a feature that's mostly used for testing.
-  CritScope cs(&g_log_crit);
-  if (streams_.size() > 0)
-    return false;
-
-  return true;
+  CritScope cs(&logCriticalScope());
+  return streamList().size() == 0;
 }
 
 void LogMessage::FinishPrintStream() {
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/logging_unittest.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/logging_unittest.cc
index a475e52d465..6b2263923fa 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/logging_unittest.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/logging_unittest.cc
@@ -221,7 +221,7 @@ TEST(LogTest, SingleStream) {
 
 #if GTEST_HAS_DEATH_TEST && !defined(WEBRTC_ANDROID)
 TEST(LogTest, Checks) {
-  EXPECT_DEATH(FATAL() << "message",
+  EXPECT_DEATH(RTC_FATAL() << "message",
                "\n\n#\n"
                "# Fatal error in: \\S+, line \\w+\n"
                "# last system error: \\w+\n"
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/never_destroyed.h b/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/never_destroyed.h
new file mode 100644
index 00000000000..fcc62e35534
--- /dev/null
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/never_destroyed.h
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2018 Apple Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#pragma once
+
+#include <type_traits>
+#include <utility>
+
+namespace rtc {
+
+template<typename T> class NeverDestroyed {
+public:
+    template<typename... Args> NeverDestroyed(Args&&... args)
+    {
+        new (storagePointer()) T(std::forward<Args>(args)...);
+    }
+
+    NeverDestroyed(NeverDestroyed&& other)
+    {
+        new (storagePointer()) T(std::move(*other.storagePointer()));
+    }
+
+    operator T&() { return *storagePointer(); }
+    T& get() { return *storagePointer(); }
+
+    operator const T&() const { return *storagePointer(); }
+    const T& get() const { return *storagePointer(); }
+
+private:
+    NeverDestroyed(const NeverDestroyed&) = delete;
+    NeverDestroyed& operator=(const NeverDestroyed&) = delete;
+
+    using PointerType = typename std::remove_const<T>::type*;
+
+    PointerType storagePointer() const { return const_cast<PointerType>(reinterpret_cast<const T*>(&m_storage)); }
+
+    // FIXME: Investigate whether we should allocate a hunk of virtual memory
+    // and hand out chunks of it to NeverDestroyed instead, to reduce fragmentation.
+    typename std::aligned_storage<sizeof(T), std::alignment_of<T>::value>::type m_storage;
+};
+
+template<typename T> inline NeverDestroyed<T> makeNeverDestroyed(T&& argument)
+{
+    return NeverDestroyed<T>(std::move(argument));
+}
+
+} // namespace rtc
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/numerics/safe_conversions.h b/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/numerics/safe_conversions.h
index 58efcaa746a..48c212e4d49 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/numerics/safe_conversions.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/numerics/safe_conversions.h
@@ -63,11 +63,11 @@ inline Dst saturated_cast(Src value) {
 
     // Should fail only on attempting to assign NaN to a saturated integer.
     case internal::TYPE_INVALID:
-      FATAL();
+      RTC_FATAL();
       return std::numeric_limits<Dst>::max();
   }
 
-  FATAL();
+  RTC_FATAL();
   return static_cast<Dst>(value);
 }
 
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/opensslcertificate.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/opensslcertificate.cc
index ed67a8938e1..236bef55c8a 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/opensslcertificate.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/opensslcertificate.cc
@@ -256,11 +256,11 @@ OpenSSLCertificate* OpenSSLCertificate::GetReference() const {
 std::string OpenSSLCertificate::ToPEMString() const {
   BIO* bio = BIO_new(BIO_s_mem());
   if (!bio) {
-    FATAL() << "unreachable code";
+    RTC_FATAL() << "unreachable code";
   }
   if (!PEM_write_bio_X509(bio, x509_)) {
     BIO_free(bio);
-    FATAL() << "unreachable code";
+    RTC_FATAL() << "unreachable code";
   }
   BIO_write(bio, "\0", 1);
   char* buffer;
@@ -277,11 +277,11 @@ void OpenSSLCertificate::ToDER(Buffer* der_buffer) const {
   // Calculates the DER representation of the certificate, from scratch.
   BIO* bio = BIO_new(BIO_s_mem());
   if (!bio) {
-    FATAL() << "unreachable code";
+    RTC_FATAL() << "unreachable code";
   }
   if (!i2d_X509_bio(bio, x509_)) {
     BIO_free(bio);
-    FATAL() << "unreachable code";
+    RTC_FATAL() << "unreachable code";
   }
   char* data;
   size_t length = BIO_get_mem_data(bio, &data);
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/stringize_macros.h b/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/stringize_macros.h
index aee8d14551d..38c6f1836bd 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/stringize_macros.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/stringize_macros.h
@@ -8,7 +8,7 @@
  *  be found in the AUTHORS file in the root of the source tree.
  */
 
-// Modified from the Chromium original:
+// Modified from the Chxsromium original:
 // src/base/strings/stringize_macros.h
 
 // This file defines preprocessor macros for stringizing preprocessor
@@ -33,6 +33,6 @@
 // Then:
 //   STRINGIZE(A) produces "FOO"
 //   STRINGIZE(B(y)) produces "myobj->FunctionCall(y)"
-#define STRINGIZE(x) STRINGIZE_NO_EXPANSION(x)
+#define RTC_STRINGIZE(x) STRINGIZE_NO_EXPANSION(x)
 
 #endif  // RTC_BASE_STRINGIZE_MACROS_H_
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/virtualsocketserver.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/virtualsocketserver.cc
index 53dad46fced..ae40d7888f5 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/virtualsocketserver.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/rtc_base/virtualsocketserver.cc
@@ -1027,9 +1027,8 @@ void VirtualSocketServer::UpdateDelayDistribution() {
   }
 }
 
-static double PI = 4 * atan(1.0);
-
 static double Normal(double x, double mean, double stddev) {
+  static const double PI = 4 * atan(1.0);
   double a = (x - mean) * (x - mean) / (2 * stddev * stddev);
   return exp(-a) / (stddev * sqrt(2 * PI));
 }
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Classes/PeerConnection/RTCH264ProfileLevelId.mm b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Classes/PeerConnection/RTCH264ProfileLevelId.mm
new file mode 100644
index 00000000000..04a5689417c
--- /dev/null
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/Framework/Classes/PeerConnection/RTCH264ProfileLevelId.mm
@@ -0,0 +1,58 @@
+/*
+ *  Copyright 2018 The WebRTC project authors. All Rights Reserved.
+ *
+ *  Use of this source code is governed by a BSD-style license
+ *  that can be found in the LICENSE file in the root of the source
+ *  tree. An additional intellectual property rights grant can be found
+ *  in the file PATENTS.  All contributing project authors may
+ *  be found in the AUTHORS file in the root of the source tree.
+ *
+ */
+
+#import "WebRTC/RTCVideoCodecH264.h"
+
+#include "media/base/h264_profile_level_id.h"
+
+@interface RTCH264ProfileLevelId ()
+
+@property(nonatomic, assign) RTCH264Profile profile;
+@property(nonatomic, assign) RTCH264Level level;
+@property(nonatomic, strong) NSString *hexString;
+
+@end
+
+@implementation RTCH264ProfileLevelId
+
+@synthesize profile = _profile;
+@synthesize level = _level;
+@synthesize hexString = _hexString;
+
+- (instancetype)initWithHexString:(NSString *)hexString {
+  if (self = [super init]) {
+    self.hexString = hexString;
+
+    absl::optional<webrtc::H264::ProfileLevelId> profile_level_id =
+        webrtc::H264::ParseProfileLevelId([hexString cStringUsingEncoding:NSUTF8StringEncoding]);
+    if (profile_level_id.has_value()) {
+      self.profile = static_cast<RTCH264Profile>(profile_level_id->profile);
+      self.level = static_cast<RTCH264Level>(profile_level_id->level);
+    }
+  }
+  return self;
+}
+
+- (instancetype)initWithProfile:(RTCH264Profile)profile level:(RTCH264Level)level {
+  if (self = [super init]) {
+    self.profile = profile;
+    self.level = level;
+
+    absl::optional<std::string> hex_string =
+        webrtc::H264::ProfileLevelIdToString(webrtc::H264::ProfileLevelId(
+            static_cast<webrtc::H264::Profile>(profile), static_cast<webrtc::H264::Level>(level)));
+    self.hexString =
+        [NSString stringWithCString:hex_string.value_or("").c_str() encoding:NSUTF8StringEncoding];
+  }
+  return self;
+}
+
+@end
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/api/peerconnection/RTCEncodedImage+Private.mm b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/api/peerconnection/RTCEncodedImage+Private.mm
index 6f2d1f46d9c..94cb1f110f9 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/api/peerconnection/RTCEncodedImage+Private.mm
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/api/peerconnection/RTCEncodedImage+Private.mm
@@ -35,6 +35,7 @@ - (instancetype)initWithNativeEncodedImage:(webrtc::EncodedImage)encodedImage {
     self.contentType = (encodedImage.content_type_ == webrtc::VideoContentType::SCREENSHARE) ?
         RTCVideoContentTypeScreenshare :
         RTCVideoContentTypeUnspecified;
+    self.spatialIndex = encodedImage.SpatialIndex() ? *encodedImage.SpatialIndex() : 0;
   }
 
   return self;
@@ -59,7 +60,8 @@ - (webrtc::EncodedImage)nativeEncodedImage {
   encodedImage.content_type_ = (self.contentType == RTCVideoContentTypeScreenshare) ?
       webrtc::VideoContentType::SCREENSHARE :
       webrtc::VideoContentType::UNSPECIFIED;
-
+  if (self.spatialIndex)
+    encodedImage.SetSpatialIndex(self.spatialIndex);
   return encodedImage;
 }
 
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/api/peerconnection/RTCRtpEncodingParameters.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/api/peerconnection/RTCRtpEncodingParameters.h
index ba50bde649f..dabff725abb 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/api/peerconnection/RTCRtpEncodingParameters.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/api/peerconnection/RTCRtpEncodingParameters.h
@@ -15,6 +15,7 @@
 NS_ASSUME_NONNULL_BEGIN
 
 RTC_OBJC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCRtpEncodingParameters")))
 @interface RTCRtpEncodingParameters : NSObject
 
 /** Controls whether the encoding is currently transmitted. */
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/api/peerconnection/RTCVideoEncoderSettings+Private.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/api/peerconnection/RTCVideoEncoderSettings+Private.h
index 5b062455bc0..72af732b23b 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/api/peerconnection/RTCVideoEncoderSettings+Private.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/api/peerconnection/RTCVideoEncoderSettings+Private.h
@@ -22,4 +22,11 @@ NS_ASSUME_NONNULL_BEGIN
 
 @end
 
+@interface RTCVideoBitrateAllocation (Private)
+
+- (instancetype)initWithNativeVideoBitrateAllocation:(const webrtc::VideoBitrateAllocation *__nullable)videoBitrateAllocation;
+- (webrtc::VideoBitrateAllocation)nativeVideoBitrateAllocation;
+
+@end
+
 NS_ASSUME_NONNULL_END
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/api/peerconnection/RTCVideoEncoderSettings+Private.mm b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/api/peerconnection/RTCVideoEncoderSettings+Private.mm
index 6fb81dbb8af..82b5ba7bc0f 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/api/peerconnection/RTCVideoEncoderSettings+Private.mm
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/api/peerconnection/RTCVideoEncoderSettings+Private.mm
@@ -12,6 +12,23 @@
 
 #import "helpers/NSString+StdString.h"
 
+@implementation RTCVideoEncoderSettings {
+  webrtc::VideoCodec _nativeVideoCodec;
+}
+
+@synthesize name = _name;
+@synthesize width = _width;
+@synthesize height = _height;
+@synthesize startBitrate = _startBitrate;
+@synthesize maxBitrate = _maxBitrate;
+@synthesize minBitrate = _minBitrate;
+@synthesize targetBitrate = _targetBitrate;
+@synthesize maxFramerate = _maxFramerate;
+@synthesize qpMax = _qpMax;
+@synthesize mode = _mode;
+
+@end
+
 @implementation RTCVideoEncoderSettings (Private)
 
 - (instancetype)initWithNativeVideoCodec:(const webrtc::VideoCodec *)videoCodec {
@@ -20,6 +37,7 @@ - (instancetype)initWithNativeVideoCodec:(const webrtc::VideoCodec *)videoCodec
       const char *codecName = CodecTypeToPayloadString(videoCodec->codecType);
       self.name = [NSString stringWithUTF8String:codecName];
 
+      _nativeVideoCodec = *videoCodec;
       self.width = videoCodec->width;
       self.height = videoCodec->height;
       self.startBitrate = videoCodec->startBitrate;
@@ -36,18 +54,28 @@ - (instancetype)initWithNativeVideoCodec:(const webrtc::VideoCodec *)videoCodec
 }
 
 - (webrtc::VideoCodec)nativeVideoCodec {
-  webrtc::VideoCodec videoCodec;
-  videoCodec.width = self.width;
-  videoCodec.height = self.height;
-  videoCodec.startBitrate = self.startBitrate;
-  videoCodec.maxBitrate = self.maxBitrate;
-  videoCodec.minBitrate = self.minBitrate;
-  videoCodec.targetBitrate = self.targetBitrate;
-  videoCodec.maxBitrate = self.maxBitrate;
-  videoCodec.qpMax = self.qpMax;
-  videoCodec.mode = (webrtc::VideoCodecMode)self.mode;
-
-  return videoCodec;
+  return _nativeVideoCodec;
+}
+
+@end
+
+@implementation RTCVideoBitrateAllocation {
+  webrtc::VideoBitrateAllocation _nativeVideoBitrateAllocation;
+}
+
+@end
+
+@implementation RTCVideoBitrateAllocation (Private)
+
+- (instancetype)initWithNativeVideoBitrateAllocation:(const webrtc::VideoBitrateAllocation *)videoBitrateAllocation {
+  if (self = [super init]) {
+    _nativeVideoBitrateAllocation = *videoBitrateAllocation;
+  }
+  return self;
+}
+
+- (webrtc::VideoBitrateAllocation)nativeVideoBitrateAllocation {
+  return _nativeVideoBitrateAllocation;
 }
 
 @end
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/api/video_codec/RTCVideoCodecConstants.mm b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/api/video_codec/RTCVideoCodecConstants.mm
index acbf126170c..1447d3b27e1 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/api/video_codec/RTCVideoCodecConstants.mm
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/api/video_codec/RTCVideoCodecConstants.mm
@@ -13,5 +13,5 @@
 
 #include "media/base/mediaconstants.h"
 
-NSString *const kRTCVideoCodecVp8Name = @(cricket::kVp8CodecName);
-NSString *const kRTCVideoCodecVp9Name = @(cricket::kVp9CodecName);
+NSString *const kRTCVideoCodecVp8Name = @"VP8";
+NSString *const kRTCVideoCodecVp9Name = @"VP9";
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/api/video_codec/RTCVideoEncoderVP8.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/api/video_codec/RTCVideoEncoderVP8.h
index 8d87a898931..08d18504222 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/api/video_codec/RTCVideoEncoderVP8.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/api/video_codec/RTCVideoEncoderVP8.h
@@ -14,6 +14,7 @@
 #import "RTCVideoEncoder.h"
 
 RTC_OBJC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCVideoEncoderVP8")))
 @interface RTCVideoEncoderVP8 : NSObject
 
 /* This returns a VP8 encoder that can be returned from a RTCVideoEncoderFactory injected into
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/api/video_codec/RTCWrappedNativeVideoEncoder.mm b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/api/video_codec/RTCWrappedNativeVideoEncoder.mm
index 9afd54f55f5..b9634779f1f 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/api/video_codec/RTCWrappedNativeVideoEncoder.mm
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/api/video_codec/RTCWrappedNativeVideoEncoder.mm
@@ -58,6 +58,11 @@ - (int)setBitrate:(uint32_t)bitrateKbit framerate:(uint32_t)framerate {
   return 0;
 }
 
+- (int)setRateAllocation:(nonnull RTCVideoBitrateAllocation *)allocation framerate:(uint32_t)framerate {
+  RTC_NOTREACHED();
+  return 0;
+}
+
 - (NSString *)implementationName {
   RTC_NOTREACHED();
   return nil;
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/api/video_frame_buffer/RTCNativeI420Buffer.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/api/video_frame_buffer/RTCNativeI420Buffer.h
index 9a904f5396a..dc903bc4bca 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/api/video_frame_buffer/RTCNativeI420Buffer.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/api/video_frame_buffer/RTCNativeI420Buffer.h
@@ -17,6 +17,7 @@ NS_ASSUME_NONNULL_BEGIN
 
 /** RTCI420Buffer implements the RTCI420Buffer protocol */
 RTC_OBJC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCI420Buffer")))
 @interface RTCI420Buffer : NSObject<RTCI420Buffer>
 @end
 
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/api/video_frame_buffer/RTCNativeMutableI420Buffer.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/api/video_frame_buffer/RTCNativeMutableI420Buffer.h
index 6cd5110460b..7cfa950abb6 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/api/video_frame_buffer/RTCNativeMutableI420Buffer.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/api/video_frame_buffer/RTCNativeMutableI420Buffer.h
@@ -18,6 +18,7 @@ NS_ASSUME_NONNULL_BEGIN
 
 /** Mutable version of RTCI420Buffer */
 RTC_OBJC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCMutableI420Buffer")))
 @interface RTCMutableI420Buffer : RTCI420Buffer<RTCMutableI420Buffer>
 @end
 
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCCodecSpecificInfo.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCCodecSpecificInfo.h
index e2ae4cafa11..9dc44c12af8 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCCodecSpecificInfo.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCCodecSpecificInfo.h
@@ -18,6 +18,7 @@ NS_ASSUME_NONNULL_BEGIN
  *  Corresponds to webrtc::CodecSpecificInfo.
  */
 RTC_OBJC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCCodecSpecificInfo")))
 @protocol RTCCodecSpecificInfo <NSObject>
 @end
 
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCEncodedImage.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCEncodedImage.h
index 670c7276ff7..7994ce64a1f 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCEncodedImage.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCEncodedImage.h
@@ -31,6 +31,7 @@ typedef NS_ENUM(NSUInteger, RTCVideoContentType) {
 
 /** Represents an encoded frame. Corresponds to webrtc::EncodedImage. */
 RTC_OBJC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCEncodedImage")))
 @interface RTCEncodedImage : NSObject
 
 @property(nonatomic, strong) NSData *buffer;
@@ -47,6 +48,7 @@ RTC_OBJC_EXPORT
 @property(nonatomic, assign) BOOL completeFrame;
 @property(nonatomic, strong) NSNumber *qp;
 @property(nonatomic, assign) RTCVideoContentType contentType;
+@property(nonatomic, assign) int spatialIndex;
 
 @end
 
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCEncodedImage.m b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCEncodedImage.m
index 024a57c541b..85cd5e298e4 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCEncodedImage.m
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCEncodedImage.m
@@ -26,5 +26,6 @@ @implementation RTCEncodedImage
 @synthesize completeFrame = _completeFrame;
 @synthesize qp = _qp;
 @synthesize contentType = _contentType;
+@synthesize spatialIndex = _spatialIndex;
 
 @end
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCI420Buffer.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCI420Buffer.h
index a6c7e41bcba..cfa14f8af23 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCI420Buffer.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCI420Buffer.h
@@ -16,6 +16,7 @@ NS_ASSUME_NONNULL_BEGIN
 
 /** Protocol for RTCYUVPlanarBuffers containing I420 data */
 RTC_OBJC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCI420Buffer")))
 @protocol RTCI420Buffer <RTCYUVPlanarBuffer>
 @end
 
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCRtpFragmentationHeader.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCRtpFragmentationHeader.h
index 2e26b08b8af..fbbc68a8ef6 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCRtpFragmentationHeader.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCRtpFragmentationHeader.h
@@ -16,6 +16,7 @@ NS_ASSUME_NONNULL_BEGIN
 
 /** Information for header. Corresponds to webrtc::RTPFragmentationHeader. */
 RTC_OBJC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCRtpFragmentationHeader")))
 @interface RTCRtpFragmentationHeader : NSObject
 
 @property(nonatomic, strong) NSArray<NSNumber *> *fragmentationOffset;
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCRtpFragmentationHeader.m b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCRtpFragmentationHeader.m
index 8049abc411e..6cf21ddc2a1 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCRtpFragmentationHeader.m
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCRtpFragmentationHeader.m
@@ -17,4 +17,5 @@ @implementation RTCRtpFragmentationHeader
 @synthesize fragmentationTimeDiff = _fragmentationTimeDiff;
 @synthesize fragmentationPlType = _fragmentationPlType;
 
-@end
\ No newline at end of file
+@end
+
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCVideoCodecInfo.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCVideoCodecInfo.h
index 2162caaa21f..4e643d94347 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCVideoCodecInfo.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCVideoCodecInfo.h
@@ -16,6 +16,7 @@ NS_ASSUME_NONNULL_BEGIN
 
 /** Holds information to identify a codec. Corresponds to webrtc::SdpVideoFormat. */
 RTC_OBJC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCVideoCodecInfo")))
 @interface RTCVideoCodecInfo : NSObject <NSCoding>
 
 - (instancetype)init NS_UNAVAILABLE;
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCVideoDecoder.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCVideoDecoder.h
index 18c6f6b0006..534420d3955 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCVideoDecoder.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCVideoDecoder.h
@@ -23,6 +23,7 @@ typedef void (^RTCVideoDecoderCallback)(RTCVideoFrame *frame);
 
 /** Protocol for decoder implementations. */
 RTC_OBJC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCVideoDecoder")))
 @protocol RTCVideoDecoder <NSObject>
 
 - (void)setCallback:(RTCVideoDecoderCallback)callback;
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCVideoDecoderFactory.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCVideoDecoderFactory.h
index 3e24153b82c..cb95fa3f134 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCVideoDecoderFactory.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCVideoDecoderFactory.h
@@ -18,6 +18,7 @@ NS_ASSUME_NONNULL_BEGIN
 
 /** RTCVideoDecoderFactory is an Objective-C version of webrtc::VideoDecoderFactory. */
 RTC_OBJC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCVideoDecoderFactory")))
 @protocol RTCVideoDecoderFactory <NSObject>
 
 - (nullable id<RTCVideoDecoder>)createDecoder:(RTCVideoCodecInfo *)info;
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCVideoEncoder.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCVideoEncoder.h
index c5257674d83..5291bb1342b 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCVideoEncoder.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCVideoEncoder.h
@@ -19,7 +19,11 @@
 #import "RTCVideoFrame.h"
 
 NS_ASSUME_NONNULL_BEGIN
-
+/*
+namespace webrtc {
+class VideoBitrateAllocation;
+};
+*/
 /** Callback block for encoder. */
 typedef BOOL (^RTCVideoEncoderCallback)(RTCEncodedImage *frame,
                                         id<RTCCodecSpecificInfo> info,
@@ -27,6 +31,7 @@ typedef BOOL (^RTCVideoEncoderCallback)(RTCEncodedImage *frame,
 
 /** Protocol for encoder implementations. */
 RTC_OBJC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCVideoEncoder")))
 @protocol RTCVideoEncoder <NSObject>
 
 - (void)setCallback:(RTCVideoEncoderCallback)callback;
@@ -37,6 +42,7 @@ RTC_OBJC_EXPORT
     codecSpecificInfo:(nullable id<RTCCodecSpecificInfo>)info
            frameTypes:(NSArray<NSNumber *> *)frameTypes;
 - (int)setBitrate:(uint32_t)bitrateKbit framerate:(uint32_t)framerate;
+- (int)setRateAllocation: (RTCVideoBitrateAllocation *)allocation framerate:(uint32_t)framerate;
 - (NSString *)implementationName;
 
 /** Returns QP scaling settings for encoder. The quality scaler adjusts the resolution in order to
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCVideoEncoderFactory.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCVideoEncoderFactory.h
index 20c603d6fe6..cbe9ea492ae 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCVideoEncoderFactory.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCVideoEncoderFactory.h
@@ -18,6 +18,7 @@ NS_ASSUME_NONNULL_BEGIN
 
 /** RTCVideoEncoderFactory is an Objective-C version of webrtc::VideoEncoderFactory. */
 RTC_OBJC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCVideoEncoderFactory")))
 @protocol RTCVideoEncoderFactory <NSObject>
 
 - (nullable id<RTCVideoEncoder>)createEncoder:(RTCVideoCodecInfo *)info;
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCVideoEncoderQpThresholds.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCVideoEncoderQpThresholds.h
index 2b48f45ce0a..68cfd66df47 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCVideoEncoderQpThresholds.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCVideoEncoderQpThresholds.h
@@ -16,6 +16,7 @@ NS_ASSUME_NONNULL_BEGIN
 
 /** QP thresholds for encoder. Corresponds to webrtc::VideoEncoder::QpThresholds. */
 RTC_OBJC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCVideoEncoderQpThresholds")))
 @interface RTCVideoEncoderQpThresholds : NSObject
 
 - (instancetype)initWithThresholdsLow:(NSInteger)low high:(NSInteger)high;
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCVideoEncoderSettings.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCVideoEncoderSettings.h
index 69e04cac70f..ae3bf5fb5f1 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCVideoEncoderSettings.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCVideoEncoderSettings.h
@@ -21,6 +21,7 @@ typedef NS_ENUM(NSUInteger, RTCVideoCodecMode) {
 
 /** Settings for encoder. Corresponds to webrtc::VideoCodec. */
 RTC_OBJC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCVideoEncoderSettings")))
 @interface RTCVideoEncoderSettings : NSObject
 
 @property(nonatomic, strong) NSString *name;
@@ -40,4 +41,9 @@ RTC_OBJC_EXPORT
 
 @end
 
+RTC_OBJC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCVideoBitrateAllocation")))
+@interface RTCVideoBitrateAllocation : NSObject
+@end
+
 NS_ASSUME_NONNULL_END
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCVideoFrame.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCVideoFrame.h
index 9aca7433f34..bde09c50c9d 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCVideoFrame.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCVideoFrame.h
@@ -26,6 +26,7 @@ typedef NS_ENUM(NSInteger, RTCVideoRotation) {
 
 // RTCVideoFrame is an ObjectiveC version of webrtc::VideoFrame.
 RTC_OBJC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCVideoFrame")))
 @interface RTCVideoFrame : NSObject
 
 /** Width without rotation applied. */
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCVideoFrameBuffer.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCVideoFrameBuffer.h
index bb9e6fba631..186ad0889bf 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCVideoFrameBuffer.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/base/RTCVideoFrameBuffer.h
@@ -18,6 +18,7 @@ NS_ASSUME_NONNULL_BEGIN
 
 // RTCVideoFrameBuffer is an ObjectiveC version of webrtc::VideoFrameBuffer.
 RTC_OBJC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCVideoFrameBuffer")))
 @protocol RTCVideoFrameBuffer <NSObject>
 
 @property(nonatomic, readonly) int width;
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/components/video_codec/RTCCodecSpecificInfoH264.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/components/video_codec/RTCCodecSpecificInfoH264.h
index ece9570a13b..e947dc6e623 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/components/video_codec/RTCCodecSpecificInfoH264.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/components/video_codec/RTCCodecSpecificInfoH264.h
@@ -10,7 +10,7 @@
 
 #import <Foundation/Foundation.h>
 
-#import "RTCCodecSpecificInfo.h"
+#import "base/RTCCodecSpecificInfo.h"
 #import "RTCMacros.h"
 
 /** Class for H264 specific config. */
@@ -20,6 +20,7 @@ typedef NS_ENUM(NSUInteger, RTCH264PacketizationMode) {
 };
 
 RTC_OBJC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCCodecSpecificInfoH264")))
 @interface RTCCodecSpecificInfoH264 : NSObject <RTCCodecSpecificInfo>
 
 @property(nonatomic, assign) RTCH264PacketizationMode packetizationMode;
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/components/video_codec/RTCDefaultVideoDecoderFactory.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/components/video_codec/RTCDefaultVideoDecoderFactory.h
index 7ca9463a593..d11460300d5 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/components/video_codec/RTCDefaultVideoDecoderFactory.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/components/video_codec/RTCDefaultVideoDecoderFactory.h
@@ -19,6 +19,7 @@ NS_ASSUME_NONNULL_BEGIN
  *  codecs, create custom implementations of RTCVideoEncoderFactory and RTCVideoDecoderFactory.
  */
 RTC_OBJC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCDefaultVideoDecoderFactory")))
 @interface RTCDefaultVideoDecoderFactory : NSObject <RTCVideoDecoderFactory>
 @end
 
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/components/video_codec/RTCDefaultVideoEncoderFactory.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/components/video_codec/RTCDefaultVideoEncoderFactory.h
index c45e54362b2..9323256cead 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/components/video_codec/RTCDefaultVideoEncoderFactory.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/components/video_codec/RTCDefaultVideoEncoderFactory.h
@@ -19,6 +19,7 @@ NS_ASSUME_NONNULL_BEGIN
  *  codecs, create custom implementations of RTCVideoEncoderFactory and RTCVideoDecoderFactory.
  */
 RTC_OBJC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCDefaultVideoEncoderFactory")))
 @interface RTCDefaultVideoEncoderFactory : NSObject <RTCVideoEncoderFactory>
 
 @property(nonatomic, retain) RTCVideoCodecInfo *preferredCodec;
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/components/video_codec/RTCH264ProfileLevelId.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/components/video_codec/RTCH264ProfileLevelId.h
index 56b353215a2..d022297674e 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/components/video_codec/RTCH264ProfileLevelId.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/components/video_codec/RTCH264ProfileLevelId.h
@@ -48,6 +48,7 @@ typedef NS_ENUM(NSUInteger, RTCH264Level) {
 };
 
 RTC_OBJC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCH264ProfileLevelId")))
 @interface RTCH264ProfileLevelId : NSObject
 
 @property(nonatomic, readonly) RTCH264Profile profile;
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/components/video_codec/RTCH264ProfileLevelId.mm b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/components/video_codec/RTCH264ProfileLevelId.mm
index 359656cb97b..28f52139c17 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/components/video_codec/RTCH264ProfileLevelId.mm
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/components/video_codec/RTCH264ProfileLevelId.mm
@@ -19,20 +19,30 @@
 #include "media/base/h264_profile_level_id.h"
 #include "media/base/mediaconstants.h"
 
+#if !defined(WEBRTC_WEBKIT_BUILD)
 namespace {
 
 NSString *MaxSupportedProfileLevelConstrainedHigh();
 NSString *MaxSupportedProfileLevelConstrainedBaseline();
 
 }  // namespace
+#endif
 
-NSString *const kRTCVideoCodecH264Name = @(cricket::kH264CodecName);
+NSString *const kRTCVideoCodecH264Name = @"H264";
 NSString *const kRTCLevel31ConstrainedHigh = @"640c1f";
 NSString *const kRTCLevel31ConstrainedBaseline = @"42e01f";
+
+#if defined(WEBRTC_WEBKIT_BUILD)
+NSString *const kRTCMaxSupportedH264ProfileLevelConstrainedHigh =
+    @"640c1f";
+NSString *const kRTCMaxSupportedH264ProfileLevelConstrainedBaseline =
+    @"42e01f";
+#else
 NSString *const kRTCMaxSupportedH264ProfileLevelConstrainedHigh =
     MaxSupportedProfileLevelConstrainedHigh();
 NSString *const kRTCMaxSupportedH264ProfileLevelConstrainedBaseline =
     MaxSupportedProfileLevelConstrainedBaseline();
+#endif
 
 namespace {
 
@@ -53,6 +63,8 @@ NSString *MaxSupportedLevelForProfile(Profile profile) {
 }
 #endif
 
+#if !defined(WEBRTC_WEBKIT_BUILD)
+
 NSString *MaxSupportedProfileLevelConstrainedBaseline() {
 #if defined(WEBRTC_IOS)
   NSString *profile = MaxSupportedLevelForProfile(webrtc::H264::kProfileConstrainedBaseline);
@@ -73,6 +85,8 @@ NSString *MaxSupportedProfileLevelConstrainedHigh() {
   return kRTCLevel31ConstrainedHigh;
 }
 
+#endif
+
 }  // namespace
 
 @interface RTCH264ProfileLevelId ()
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/components/video_codec/RTCVideoDecoderFactoryH264.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/components/video_codec/RTCVideoDecoderFactoryH264.h
index 4fcff1dff79..fdabd807480 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/components/video_codec/RTCVideoDecoderFactoryH264.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/components/video_codec/RTCVideoDecoderFactoryH264.h
@@ -14,5 +14,6 @@
 #import "RTCVideoDecoderFactory.h"
 
 RTC_OBJC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCVideoDecoderFactoryH264")))
 @interface RTCVideoDecoderFactoryH264 : NSObject <RTCVideoDecoderFactory>
 @end
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/components/video_codec/RTCVideoDecoderH264.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/components/video_codec/RTCVideoDecoderH264.h
index b860276206c..b10d1e6a099 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/components/video_codec/RTCVideoDecoderH264.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/components/video_codec/RTCVideoDecoderH264.h
@@ -14,5 +14,6 @@
 #import "RTCVideoDecoder.h"
 
 RTC_OBJC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCVideoDecoderH264")))
 @interface RTCVideoDecoderH264 : NSObject <RTCVideoDecoder>
 @end
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/components/video_codec/RTCVideoEncoderFactoryH264.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/components/video_codec/RTCVideoEncoderFactoryH264.h
index c64405e4dac..5f6f78dfa9a 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/components/video_codec/RTCVideoEncoderFactoryH264.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/components/video_codec/RTCVideoEncoderFactoryH264.h
@@ -14,5 +14,6 @@
 #import "RTCVideoEncoderFactory.h"
 
 RTC_OBJC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCVideoEncoderFactoryH264")))
 @interface RTCVideoEncoderFactoryH264 : NSObject <RTCVideoEncoderFactory>
 @end
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/components/video_codec/RTCVideoEncoderH264.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/components/video_codec/RTCVideoEncoderH264.h
index a9c05580a41..7714b25eaa4 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/components/video_codec/RTCVideoEncoderH264.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/components/video_codec/RTCVideoEncoderH264.h
@@ -15,6 +15,7 @@
 #import "RTCVideoEncoder.h"
 
 RTC_OBJC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCVideoEncoderH264")))
 @interface RTCVideoEncoderH264 : NSObject <RTCVideoEncoder>
 
 - (instancetype)initWithCodecInfo:(RTCVideoCodecInfo *)codecInfo;
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/components/video_codec/RTCVideoEncoderH264.mm b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/components/video_codec/RTCVideoEncoderH264.mm
index 16ad1ff47aa..9013ba962fb 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/components/video_codec/RTCVideoEncoderH264.mm
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/components/video_codec/RTCVideoEncoderH264.mm
@@ -9,39 +9,72 @@
  *
  */
 
-#import "RTCVideoEncoderH264.h"
+#import "WebRTC/RTCVideoCodecH264.h"
 
 #import <VideoToolbox/VideoToolbox.h>
 #include <vector>
 
 #if defined(WEBRTC_IOS)
-#import "helpers/UIDevice+RTCDevice.h"
+#import "Common/RTCUIApplicationStatusObserver.h"
+#import "WebRTC/UIDevice+RTCDevice.h"
 #endif
-#import "RTCCodecSpecificInfoH264.h"
-#import "RTCH264ProfileLevelId.h"
-#import "api/peerconnection/RTCRtpFragmentationHeader+Private.h"
-#import "api/peerconnection/RTCVideoCodecInfo+Private.h"
-#import "base/RTCCodecSpecificInfo.h"
-#import "base/RTCI420Buffer.h"
-#import "base/RTCVideoEncoder.h"
-#import "base/RTCVideoFrame.h"
-#import "base/RTCVideoFrameBuffer.h"
-#import "components/video_frame_buffer/RTCCVPixelBuffer.h"
-#import "helpers.h"
-
+#import "PeerConnection/RTCVideoCodec+Private.h"
+#import "WebRTC/RTCVideoCodec.h"
+#import "WebRTC/RTCVideoFrame.h"
+#import "WebRTC/RTCVideoFrameBuffer.h"
 #include "common_video/h264/h264_bitstream_parser.h"
 #include "common_video/h264/profile_level_id.h"
 #include "common_video/include/bitrate_adjuster.h"
+#import "helpers.h"
 #include "modules/include/module_common_types.h"
 #include "modules/video_coding/include/video_error_codes.h"
 #include "rtc_base/buffer.h"
 #include "rtc_base/logging.h"
 #include "rtc_base/timeutils.h"
-#include "sdk/objc/components/video_codec/nalu_rewriter.h"
+#include "sdk/objc/Framework/Classes/VideoToolbox/nalu_rewriter.h"
+#include "system_wrappers/include/clock.h"
 #include "third_party/libyuv/include/libyuv/convert_from.h"
 
-@interface RTCVideoEncoderH264 ()
+#include "sdk/WebKit/EncoderUtilities.h"
+#include "sdk/WebKit/WebKitUtilities.h"
+
+#import <dlfcn.h>
+#import <objc/runtime.h>
+
+SOFT_LINK_FRAMEWORK_OPTIONAL(VideoToolBox)
+SOFT_LINK_POINTER_OPTIONAL(VideoToolBox, kVTVideoEncoderSpecification_Usage, NSString *)
+
+#if !ENABLE_VCP_ENCODER && !defined(WEBRTC_IOS)
+static inline bool isStandardFrameSize(int32_t width, int32_t height)
+{
+    // FIXME: Envision relaxing this rule, something like width and height dividable by 4 or 8 should be good enough.
+    if (width == 1280)
+        return height == 720;
+    if (width == 720)
+        return height == 1280;
+    if (width == 960)
+        return height == 540;
+    if (width == 540)
+        return height == 960;
+    if (width == 640)
+        return height == 480;
+    if (width == 480)
+        return height == 640;
+    if (width == 288)
+        return height == 352;
+    if (width == 352)
+        return height == 288;
+    if (width == 320)
+        return height == 240;
+    if (width == 240)
+        return height == 320;
+    return false;
+}
+#endif
 
+__attribute__((objc_runtime_name("WK_RTCSingleVideoEncoderH264")))
+@interface RTCSingleVideoEncoderH264 : NSObject <RTCVideoEncoder>
+- (instancetype)initWithCodecInfo:(RTCVideoCodecInfo *)codecInfo simulcastIndex: (int)index;
 - (void)frameWasEncoded:(OSStatus)status
                   flags:(VTEncodeInfoFlags)infoFlags
            sampleBuffer:(CMSampleBufferRef)sampleBuffer
@@ -51,7 +84,6 @@ - (void)frameWasEncoded:(OSStatus)status
            renderTimeMs:(int64_t)renderTimeMs
               timestamp:(uint32_t)timestamp
                rotation:(RTCVideoRotation)rotation;
-
 @end
 
 namespace {  // anonymous namespace
@@ -70,7 +102,7 @@ const OSType kNV12PixelFormat = kCVPixelFormatType_420YpCbCr8BiPlanarFullRange;
 // Struct that we pass to the encoder per frame to encode. We receive it again
 // in the encoder callback.
 struct RTCFrameEncodeParams {
-  RTCFrameEncodeParams(RTCVideoEncoderH264 *e,
+  RTCFrameEncodeParams(RTCSingleVideoEncoderH264 *e,
                        RTCCodecSpecificInfoH264 *csi,
                        int32_t w,
                        int32_t h,
@@ -85,7 +117,7 @@ struct RTCFrameEncodeParams {
     }
   }
 
-  RTCVideoEncoderH264 *encoder;
+  RTCSingleVideoEncoderH264 *encoder;
   RTCCodecSpecificInfoH264 *codecSpecificInfo;
   int32_t width;
   int32_t height;
@@ -173,8 +205,8 @@ void compressionOutputCallback(void *encoder,
                                 rotation:encodeParams->rotation];
 }
 
-// Extract VideoToolbox profile out of the webrtc::SdpVideoFormat. If there is
-// no specific VideoToolbox profile for the specified level, AutoLevel will be
+// Extract VideoToolbox profile out of the cricket::VideoCodec. If there is no
+// specific VideoToolbox profile for the specified level, AutoLevel will be
 // returned. The user must initialize the encoder with a resolution and
 // framerate conforming to the selected H264 level regardless.
 CFStringRef ExtractProfile(webrtc::SdpVideoFormat videoFormat) {
@@ -280,7 +312,7 @@ CFStringRef ExtractProfile(webrtc::SdpVideoFormat videoFormat) {
 }
 }  // namespace
 
-@implementation RTCVideoEncoderH264 {
+@implementation RTCSingleVideoEncoderH264 {
   RTCVideoCodecInfo *_codecInfo;
   std::unique_ptr<webrtc::BitrateAdjuster> _bitrateAdjuster;
   uint32_t _targetBitrateBps;
@@ -290,12 +322,14 @@ @implementation RTCVideoEncoderH264 {
   RTCVideoEncoderCallback _callback;
   int32_t _width;
   int32_t _height;
-  VTCompressionSessionRef _compressionSession;
-  CVPixelBufferPoolRef _pixelBufferPool;
+  CompressionSessionRef _compressionSession;
   RTCVideoCodecMode _mode;
 
   webrtc::H264BitstreamParser _h264BitstreamParser;
   std::vector<uint8_t> _frameScaleBuffer;
+
+  webrtc::VideoCodec _nativeVideoCodec;
+  int _simulcastIndex;
 }
 
 // .5 is set as a mininum to prevent overcompensating for large temporary
@@ -305,14 +339,19 @@ @implementation RTCVideoEncoderH264 {
 // drastically reduced bitrate, so we want to avoid that. In steady state
 // conditions, 0.95 seems to give us better overall bitrate over long periods
 // of time.
-- (instancetype)initWithCodecInfo:(RTCVideoCodecInfo *)codecInfo {
+- (instancetype)initWithCodecInfo:(RTCVideoCodecInfo *)codecInfo simulcastIndex:(int)index {
   if (self = [super init]) {
     _codecInfo = codecInfo;
     _bitrateAdjuster.reset(new webrtc::BitrateAdjuster(.5, .95));
     _packetizationMode = RTCH264PacketizationModeNonInterleaved;
     _profile = ExtractProfile([codecInfo nativeSdpVideoFormat]);
+    _simulcastIndex = index;
     RTC_LOG(LS_INFO) << "Using profile " << CFStringToString(_profile);
     RTC_CHECK([codecInfo.name isEqualToString:kRTCVideoCodecH264Name]);
+
+#if defined(WEBRTC_IOS)
+    [RTCUIApplicationStatusObserver prepareForUse];
+#endif
   }
   return self;
 }
@@ -329,9 +368,12 @@ - (NSInteger)startEncodeWithSettings:(RTCVideoEncoderSettings *)settings
   _width = settings.width;
   _height = settings.height;
   _mode = settings.mode;
+  _nativeVideoCodec = settings.nativeVideoCodec;
+
+  RTC_DCHECK(_nativeVideoCodec.numberOfSimulcastStreams != 1);
 
   // We can only set average bitrate on the HW encoder.
-  _targetBitrateBps = settings.startBitrate * 1000;  // startBitrate is in kbps.
+  _targetBitrateBps = settings.startBitrate;
   _bitrateAdjuster->SetTargetBitrateBps(_targetBitrateBps);
 
   // TODO(tkchin): Try setting payload size via
@@ -348,10 +390,20 @@ - (NSInteger)encode:(RTCVideoFrame *)frame
   if (!_callback || !_compressionSession) {
     return WEBRTC_VIDEO_CODEC_UNINITIALIZED;
   }
+#if defined(WEBRTC_IOS)
+  if (![[RTCUIApplicationStatusObserver sharedInstance] isApplicationActive]) {
+    // Ignore all encode requests when app isn't active. In this state, the
+    // hardware encoder has been invalidated by the OS.
+    return WEBRTC_VIDEO_CODEC_OK;
+  }
+#endif
   BOOL isKeyframeRequired = NO;
 
   // Get a pixel buffer from the pool and copy frame data over.
-  if ([self resetCompressionSessionIfNeededWithFrame:frame]) {
+  CVPixelBufferPoolRef pixelBufferPool =
+      CompressionSessionGetPixelBufferPool(_compressionSession);
+  if ([self resetCompressionSessionIfNeededForPool:pixelBufferPool withFrame:frame]) {
+    pixelBufferPool = CompressionSessionGetPixelBufferPool(_compressionSession);
     isKeyframeRequired = YES;
   }
 
@@ -368,7 +420,7 @@ - (NSInteger)encode:(RTCVideoFrame *)frame
       CVBufferRetain(pixelBuffer);
     } else {
       // Cropping required, we need to crop and scale to a new pixel buffer.
-      pixelBuffer = CreatePixelBuffer(_pixelBufferPool);
+      pixelBuffer = CreatePixelBuffer(pixelBufferPool);
       if (!pixelBuffer) {
         return WEBRTC_VIDEO_CODEC_ERROR;
       }
@@ -391,7 +443,7 @@ - (NSInteger)encode:(RTCVideoFrame *)frame
 
   if (!pixelBuffer) {
     // We did not have a native frame buffer
-    pixelBuffer = CreatePixelBuffer(_pixelBufferPool);
+    pixelBuffer = CreatePixelBuffer(pixelBufferPool);
     if (!pixelBuffer) {
       return WEBRTC_VIDEO_CODEC_ERROR;
     }
@@ -434,7 +486,7 @@ - (NSInteger)encode:(RTCVideoFrame *)frame
   // Update the bitrate if needed.
   [self setBitrateBps:_bitrateAdjuster->GetAdjustedBitrateBps()];
 
-  OSStatus status = VTCompressionSessionEncodeFrame(_compressionSession,
+  OSStatus status = CompressionSessionEncodeFrame(_compressionSession,
                                                     pixelBuffer,
                                                     presentationTimeStamp,
                                                     kCMTimeInvalid,
@@ -447,14 +499,7 @@ - (NSInteger)encode:(RTCVideoFrame *)frame
   if (pixelBuffer) {
     CVBufferRelease(pixelBuffer);
   }
-
-  if (status == kVTInvalidSessionErr) {
-    // This error occurs when entering foreground after backgrounding the app.
-    RTC_LOG(LS_ERROR) << "Invalid compression session, resetting.";
-    [self resetCompressionSessionWithPixelFormat:[self pixelFormatOfFrame:frame]];
-
-    return WEBRTC_VIDEO_CODEC_NO_OUTPUT;
-  } else if (status != noErr) {
+  if (status != noErr) {
     RTC_LOG(LS_ERROR) << "Failed to encode frame with code: " << status;
     return WEBRTC_VIDEO_CODEC_ERROR;
   }
@@ -465,8 +510,8 @@ - (void)setCallback:(RTCVideoEncoderCallback)callback {
   _callback = callback;
 }
 
-- (int)setBitrate:(uint32_t)bitrateKbit framerate:(uint32_t)framerate {
-  _targetBitrateBps = 1000 * bitrateKbit;
+- (int)setBitrate:(uint32_t)bitrateBps framerate:(uint32_t)framerate {
+  _targetBitrateBps = bitrateBps;
   _bitrateAdjuster->SetTargetBitrateBps(_targetBitrateBps);
   [self setBitrateBps:_bitrateAdjuster->GetAdjustedBitrateBps()];
   return WEBRTC_VIDEO_CODEC_OK;
@@ -483,44 +528,51 @@ - (NSInteger)releaseEncoder {
   return WEBRTC_VIDEO_CODEC_OK;
 }
 
-- (OSType)pixelFormatOfFrame:(RTCVideoFrame *)frame {
-  // Use NV12 for non-native frames.
-  if ([frame.buffer isKindOfClass:[RTCCVPixelBuffer class]]) {
-    RTCCVPixelBuffer *rtcPixelBuffer = (RTCCVPixelBuffer *)frame.buffer;
-    return CVPixelBufferGetPixelFormatType(rtcPixelBuffer.pixelBuffer);
-  }
-
-  return kNV12PixelFormat;
-}
-
-- (BOOL)resetCompressionSessionIfNeededWithFrame:(RTCVideoFrame *)frame {
+- (BOOL)resetCompressionSessionIfNeededForPool:(CVPixelBufferPoolRef)pixelBufferPool
+                                     withFrame:(RTCVideoFrame *)frame {
   BOOL resetCompressionSession = NO;
 
+#if defined(WEBRTC_IOS)
+  if (!pixelBufferPool) {
+    // Kind of a hack. On backgrounding, the compression session seems to get
+    // invalidated, which causes this pool call to fail when the application
+    // is foregrounded and frames are being sent for encoding again.
+    // Resetting the session when this happens fixes the issue.
+    // In addition we request a keyframe so video can recover quickly.
+    resetCompressionSession = YES;
+    RTC_LOG(LS_INFO) << "Resetting compression session due to invalid pool.";
+  }
+#endif
+
   // If we're capturing native frames in another pixel format than the compression session is
   // configured with, make sure the compression session is reset using the correct pixel format.
-  OSType framePixelFormat = [self pixelFormatOfFrame:frame];
-
-  if (_compressionSession) {
+  // If we're capturing non-native frames and the compression session is configured with a non-NV12
+  // format, reset it to NV12.
+  OSType framePixelFormat = kNV12PixelFormat;
+  if (pixelBufferPool) {
     // The pool attribute `kCVPixelBufferPixelFormatTypeKey` can contain either an array of pixel
     // formats or a single pixel format.
     NSDictionary *poolAttributes =
-        (__bridge NSDictionary *)CVPixelBufferPoolGetPixelBufferAttributes(_pixelBufferPool);
+        (__bridge NSDictionary *)CVPixelBufferPoolGetPixelBufferAttributes(pixelBufferPool);
     id pixelFormats =
         [poolAttributes objectForKey:(__bridge NSString *)kCVPixelBufferPixelFormatTypeKey];
     NSArray<NSNumber *> *compressionSessionPixelFormats = nil;
     if ([pixelFormats isKindOfClass:[NSArray class]]) {
       compressionSessionPixelFormats = (NSArray *)pixelFormats;
-    } else if ([pixelFormats isKindOfClass:[NSNumber class]]) {
+    } else {
       compressionSessionPixelFormats = @[ (NSNumber *)pixelFormats ];
     }
 
+    if ([frame.buffer isKindOfClass:[RTCCVPixelBuffer class]]) {
+      RTCCVPixelBuffer *rtcPixelBuffer = (RTCCVPixelBuffer *)frame.buffer;
+      framePixelFormat = CVPixelBufferGetPixelFormatType(rtcPixelBuffer.pixelBuffer);
+    }
+
     if (![compressionSessionPixelFormats
             containsObject:[NSNumber numberWithLong:framePixelFormat]]) {
       resetCompressionSession = YES;
       RTC_LOG(LS_INFO) << "Resetting compression session due to non-matching pixel format.";
     }
-  } else {
-    resetCompressionSession = YES;
   }
 
   if (resetCompressionSession) {
@@ -557,22 +609,26 @@ - (int)resetCompressionSessionWithPixelFormat:(OSType)framePixelFormat {
     CFRelease(pixelFormat);
     pixelFormat = nullptr;
   }
-  CFMutableDictionaryRef encoder_specs = nullptr;
-#if defined(WEBRTC_MAC) && !defined(WEBRTC_IOS)
+  CFDictionaryRef encoderSpecs = nullptr;
+#if !defined(WEBRTC_IOS)
+  auto useHardwareEncoder = webrtc::isH264HardwareEncoderAllowed() ? kCFBooleanTrue : kCFBooleanFalse;
   // Currently hw accl is supported above 360p on mac, below 360p
   // the compression session will be created with hw accl disabled.
-  encoder_specs = CFDictionaryCreateMutable(
-      nullptr, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
-  CFDictionarySetValue(encoder_specs,
-                       kVTVideoEncoderSpecification_EnableHardwareAcceleratedVideoEncoder,
-                       kCFBooleanTrue);
+  CFTypeRef sessionKeys[] = { kVTVideoEncoderSpecification_EnableHardwareAcceleratedVideoEncoder, kVTVideoEncoderSpecification_RequireHardwareAcceleratedVideoEncoder, kVTCompressionPropertyKey_RealTime };
+  CFTypeRef sessionValues[] = { useHardwareEncoder, useHardwareEncoder, kCFBooleanTrue };
+  encoderSpecs = CFDictionaryCreate(kCFAllocatorDefault, sessionKeys, sessionValues, 3, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
+#else
+  CFTypeRef sessionKeys[] = { kVTCompressionPropertyKey_RealTime };
+  CFTypeRef sessionValues[] = { kCFBooleanTrue };
+  encoderSpecs = CFDictionaryCreate(kCFAllocatorDefault, sessionKeys, sessionValues, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
 #endif
+
   OSStatus status =
-      VTCompressionSessionCreate(nullptr,  // use default allocator
+      CompressionSessionCreate(nullptr,  // use default allocator
                                  _width,
                                  _height,
-                                 kCMVideoCodecType_H264,
-                                 encoder_specs,  // use hardware accelerated encoder if available
+                                 kCodecTypeH264,
+                                 encoderSpecs,  // use hardware accelerated encoder if available
                                  sourceAttributes,
                                  nullptr,  // use default compressed data allocator
                                  compressionOutputCallback,
@@ -582,32 +638,105 @@ - (int)resetCompressionSessionWithPixelFormat:(OSType)framePixelFormat {
     CFRelease(sourceAttributes);
     sourceAttributes = nullptr;
   }
-  if (encoder_specs) {
-    CFRelease(encoder_specs);
-    encoder_specs = nullptr;
+  if (encoderSpecs) {
+    CFRelease(encoderSpecs);
+    encoderSpecs = nullptr;
   }
+
+#if ENABLE_VCP_ENCODER || defined(WEBRTC_IOS)
   if (status != noErr) {
     RTC_LOG(LS_ERROR) << "Failed to create compression session: " << status;
     return WEBRTC_VIDEO_CODEC_ERROR;
   }
+#endif
 #if defined(WEBRTC_MAC) && !defined(WEBRTC_IOS)
   CFBooleanRef hwaccl_enabled = nullptr;
-  status = VTSessionCopyProperty(_compressionSession,
+  if (status == noErr) {
+    status = VTSessionCopyProperty(_compressionSession,
                                  kVTCompressionPropertyKey_UsingHardwareAcceleratedVideoEncoder,
                                  nullptr,
                                  &hwaccl_enabled);
+  }
   if (status == noErr && (CFBooleanGetValue(hwaccl_enabled))) {
     RTC_LOG(LS_INFO) << "Compression session created with hw accl enabled";
   } else {
     RTC_LOG(LS_INFO) << "Compression session created with hw accl disabled";
+
+#if !ENABLE_VCP_ENCODER && !defined(WEBRTC_IOS)
+    if (!isStandardFrameSize(_width, _height)) {
+      RTC_LOG(LS_ERROR) << "Using H264 software encoder with non standard size is not supported";
+      return WEBRTC_VIDEO_CODEC_ERROR;
+    }
+
+    if (!getkVTVideoEncoderSpecification_Usage()) {
+      RTC_LOG(LS_ERROR) << "RTCSingleVideoEncoderH264 cannot create a H264 software encoder";
+      return WEBRTC_VIDEO_CODEC_ERROR;
+    }
+
+    CFDictionaryRef ioSurfaceValue = CreateCFTypeDictionary(nullptr, nullptr, 0);
+    int64_t pixelFormatType = framePixelFormat;
+    CFNumberRef pixelFormat = CFNumberCreate(nullptr, kCFNumberLongType, &pixelFormatType);
+
+    const size_t attributesSize = 3;
+    CFTypeRef keys[attributesSize] = {
+      kCVPixelBufferOpenGLCompatibilityKey,
+      kCVPixelBufferIOSurfacePropertiesKey,
+      kCVPixelBufferPixelFormatTypeKey
+    };
+    CFTypeRef values[attributesSize] = {
+      kCFBooleanTrue,
+      ioSurfaceValue,
+      pixelFormat};
+    CFDictionaryRef sourceAttributes = CreateCFTypeDictionary(keys, values, attributesSize);
+
+    if (ioSurfaceValue) {
+      CFRelease(ioSurfaceValue);
+      ioSurfaceValue = nullptr;
+    }
+    if (pixelFormat) {
+      CFRelease(pixelFormat);
+      pixelFormat = nullptr;
+    }
+
+    CFMutableDictionaryRef encoderSpecs = CFDictionaryCreateMutable(nullptr, 2, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
+    CFDictionarySetValue(encoderSpecs, kVTVideoEncoderSpecification_EnableHardwareAcceleratedVideoEncoder, kCFBooleanFalse);
+    int usageValue = 1;
+    CFNumberRef usage = CFNumberCreate(nullptr, kCFNumberIntType, &usageValue);
+    CFDictionarySetValue(encoderSpecs, (__bridge CFStringRef)getkVTVideoEncoderSpecification_Usage(), usage);
+
+    if (usage) {
+      CFRelease(usage);
+      usage = nullptr;
+    }
+
+    [self destroyCompressionSession];
+
+    OSStatus status =
+      CompressionSessionCreate(nullptr,  // use default allocator
+                                 _width,
+                                 _height,
+                                 kCodecTypeH264,
+                                 encoderSpecs,
+                                 sourceAttributes,
+                                 nullptr,  // use default compressed data allocator
+                                 compressionOutputCallback,
+                                 nullptr,
+                                 &_compressionSession);
+    if (sourceAttributes) {
+      CFRelease(sourceAttributes);
+      sourceAttributes = nullptr;
+    }
+    if (encoderSpecs) {
+      CFRelease(encoderSpecs);
+      encoderSpecs = nullptr;
+    }
+    if (status != noErr) {
+      return WEBRTC_VIDEO_CODEC_ERROR;
+    }
+#endif
   }
 #endif
   [self configureCompressionSession];
-
-  // The pixel buffer pool is dependent on the compression session so if the session is reset, the
-  // pool should be reset as well.
-  _pixelBufferPool = VTCompressionSessionGetPixelBufferPool(_compressionSession);
-
   return WEBRTC_VIDEO_CODEC_OK;
 }
 
@@ -616,6 +745,10 @@ - (void)configureCompressionSession {
   SetVTSessionProperty(_compressionSession, kVTCompressionPropertyKey_RealTime, true);
   SetVTSessionProperty(_compressionSession, kVTCompressionPropertyKey_ProfileLevel, _profile);
   SetVTSessionProperty(_compressionSession, kVTCompressionPropertyKey_AllowFrameReordering, false);
+#if ENABLE_VCP_ENCODER
+  if (auto key = getkVTVideoEncoderSpecification_Usage())
+      SetVTSessionProperty(_compressionSession, (__bridge CFStringRef)key, 1);
+#endif
   [self setEncoderBitrateBps:_targetBitrateBps];
   // TODO(tkchin): Look at entropy mode and colorspace matrices.
   // TODO(tkchin): Investigate to see if there's any way to make this work.
@@ -633,10 +766,9 @@ - (void)configureCompressionSession {
 
 - (void)destroyCompressionSession {
   if (_compressionSession) {
-    VTCompressionSessionInvalidate(_compressionSession);
+    CompressionSessionInvalidate(_compressionSession);
     CFRelease(_compressionSession);
     _compressionSession = nullptr;
-    _pixelBufferPool = nullptr;
   }
 }
 
@@ -664,7 +796,7 @@ - (void)setEncoderBitrateBps:(uint32_t)bitrateBps {
         CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt64Type, &oneSecondValue);
     const void *nums[2] = {bytesPerSecond, oneSecond};
     CFArrayRef dataRateLimits = CFArrayCreate(nullptr, nums, 2, &kCFTypeArrayCallBacks);
-    OSStatus status = VTSessionSetProperty(
+    OSStatus status = CompressionSessionSetProperty(
         _compressionSession, kVTCompressionPropertyKey_DataRateLimits, dataRateLimits);
     if (bytesPerSecond) {
       CFRelease(bytesPerSecond);
@@ -676,7 +808,7 @@ - (void)setEncoderBitrateBps:(uint32_t)bitrateBps {
       CFRelease(dataRateLimits);
     }
     if (status != noErr) {
-      RTC_LOG(LS_ERROR) << "Failed to set data rate limit with code: " << status;
+      RTC_LOG(LS_ERROR) << "Failed to set data rate limit";
     }
 
     _encoderBitrateBps = bitrateBps;
@@ -693,7 +825,7 @@ - (void)frameWasEncoded:(OSStatus)status
               timestamp:(uint32_t)timestamp
                rotation:(RTCVideoRotation)rotation {
   if (status != noErr) {
-    RTC_LOG(LS_ERROR) << "H264 encode failed with code: " << status;
+    RTC_LOG(LS_ERROR) << "H264 encode failed: " << status;
     return;
   }
   if (infoFlags & kVTEncodeInfo_FrameDropped) {
@@ -738,6 +870,7 @@ - (void)frameWasEncoded:(OSStatus)status
   frame.rotation = rotation;
   frame.contentType = (_mode == RTCVideoCodecModeScreensharing) ? RTCVideoContentTypeScreenshare :
                                                                   RTCVideoContentTypeUnspecified;
+  frame.spatialIndex = _simulcastIndex;
   frame.flags = webrtc::VideoSendTiming::kInvalid;
 
   int qp;
@@ -753,9 +886,88 @@ - (void)frameWasEncoded:(OSStatus)status
   _bitrateAdjuster->Update(frame.buffer.length);
 }
 
-- (nullable RTCVideoEncoderQpThresholds *)scalingSettings {
-  return [[RTCVideoEncoderQpThresholds alloc] initWithThresholdsLow:kLowH264QpThreshold
-                                                               high:kHighH264QpThreshold];
+- (RTCVideoEncoderQpThresholds *)scalingSettings {
+  return [[RTCVideoEncoderQpThresholds alloc] initWithThresholdsLow:kLowH264QpThreshold high:kHighH264QpThreshold];
+}
+
+- (int)setRateAllocation:(RTCVideoBitrateAllocation *)allocation framerate:(uint32_t)framerate {
+  return 0;
+}
+
+@end
+
+@implementation RTCVideoEncoderH264 {
+  NSMutableArray<RTCSingleVideoEncoderH264*> *_codecs;
+  RTCVideoCodecInfo *_codecInfo;
+}
+- (instancetype)initWithCodecInfo:(RTCVideoCodecInfo *)codecInfo {
+  if (self = [super init]) {
+    _codecInfo = codecInfo;
+  }
+  return self;
+}
+
+- (void)setCallback:(RTCVideoEncoderCallback)callback {
+  for (RTCSingleVideoEncoderH264 *codec : _codecs)
+    [codec setCallback:callback];
+}
+
+- (NSInteger)startEncodeWithSettings:(RTCVideoEncoderSettings *)settings numberOfCores:(int)numberOfCores {
+    auto nativeCodecSettings = settings.nativeVideoCodec;
+
+  _codecs = [[NSMutableArray alloc] init];
+  for (unsigned index = 0 ; index < nativeCodecSettings.numberOfSimulcastStreams; ++index) {
+    auto codec = [[RTCSingleVideoEncoderH264 alloc] initWithCodecInfo:_codecInfo simulcastIndex:index];
+    [_codecs addObject:codec];
+
+    auto codecSettings = nativeCodecSettings;
+    codecSettings.width = nativeCodecSettings.simulcastStream[index].width;
+    codecSettings.height = nativeCodecSettings.simulcastStream[index].height;
+    codecSettings.maxBitrate = nativeCodecSettings.simulcastStream[index].maxBitrate;
+    codecSettings.targetBitrate = nativeCodecSettings.simulcastStream[index].targetBitrate;
+    codecSettings.minBitrate = nativeCodecSettings.simulcastStream[index].minBitrate;
+    codecSettings.qpMax = nativeCodecSettings.simulcastStream[index].qpMax;
+    codecSettings.active = true;
+
+    auto *settings = [[RTCVideoEncoderSettings alloc] initWithNativeVideoCodec:&codecSettings];
+    [codec startEncodeWithSettings:settings numberOfCores:numberOfCores];
+  }
+  return 0;
+}
+
+- (NSInteger)releaseEncoder {
+  for (RTCSingleVideoEncoderH264 *codec : _codecs)
+    [codec releaseEncoder];
+  _codecs = nil;
+  return 0;
+}
+
+- (NSInteger)encode:(RTCVideoFrame *)frame codecSpecificInfo:(nullable id<RTCCodecSpecificInfo>)info frameTypes:(NSArray<NSNumber *> *)frameTypes {
+  int result = 0;
+  for (RTCSingleVideoEncoderH264 *codec : _codecs)
+    result |= [codec encode:frame codecSpecificInfo:info frameTypes:frameTypes];
+  return result;
+}
+
+- (int)setRateAllocation:(RTCVideoBitrateAllocation *)bitRateAllocation framerate:(uint32_t) framerate {
+  int result = 0;
+  unsigned counter = 0;
+  auto nativeBitRateAllocation = bitRateAllocation.nativeVideoBitrateAllocation;
+  for (RTCSingleVideoEncoderH264 *codec : _codecs)
+    result |= [codec setBitrate:nativeBitRateAllocation.GetSpatialLayerSum(counter++) framerate:framerate];
+  return result;
+}
+
+- (NSString *)implementationName {
+  return @"VideoToolbox";
+}
+
+- (RTCVideoEncoderQpThresholds *)scalingSettings {
+  return [[RTCVideoEncoderQpThresholds alloc] initWithThresholdsLow:kLowH264QpThreshold high:kHighH264QpThreshold];
+}
+
+- (int)setBitrate:(uint32_t)bitrateKbit framerate:(uint32_t)framerate {
+  return 0;
 }
 
 @end
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/components/video_codec/helpers.cc b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/components/video_codec/helpers.cc
index ac957f1b497..46daf44ecac 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/components/video_codec/helpers.cc
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/components/video_codec/helpers.cc
@@ -35,12 +35,12 @@ std::string CFStringToString(const CFStringRef cf_string) {
 }
 
 // Convenience function for setting a VT property.
-void SetVTSessionProperty(VTSessionRef session,
+void SetVTSessionProperty(CompressionSessionRef session,
                           CFStringRef key,
                           int32_t value) {
   CFNumberRef cfNum =
       CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &value);
-  OSStatus status = VTSessionSetProperty(session, key, cfNum);
+  OSStatus status = CompressionSessionSetProperty(session, key, cfNum);
   CFRelease(cfNum);
   if (status != noErr) {
     std::string key_string = CFStringToString(key);
@@ -50,13 +50,13 @@ void SetVTSessionProperty(VTSessionRef session,
 }
 
 // Convenience function for setting a VT property.
-void SetVTSessionProperty(VTSessionRef session,
+void SetVTSessionProperty(CompressionSessionRef session,
                           CFStringRef key,
                           uint32_t value) {
   int64_t value_64 = value;
   CFNumberRef cfNum =
       CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt64Type, &value_64);
-  OSStatus status = VTSessionSetProperty(session, key, cfNum);
+  OSStatus status = CompressionSessionSetProperty(session, key, cfNum);
   CFRelease(cfNum);
   if (status != noErr) {
     std::string key_string = CFStringToString(key);
@@ -66,9 +66,9 @@ void SetVTSessionProperty(VTSessionRef session,
 }
 
 // Convenience function for setting a VT property.
-void SetVTSessionProperty(VTSessionRef session, CFStringRef key, bool value) {
+void SetVTSessionProperty(CompressionSessionRef session, CFStringRef key, bool value) {
   CFBooleanRef cf_bool = (value) ? kCFBooleanTrue : kCFBooleanFalse;
-  OSStatus status = VTSessionSetProperty(session, key, cf_bool);
+  OSStatus status = CompressionSessionSetProperty(session, key, cf_bool);
   if (status != noErr) {
     std::string key_string = CFStringToString(key);
     RTC_LOG(LS_ERROR) << "VTSessionSetProperty failed to set: " << key_string
@@ -77,10 +77,10 @@ void SetVTSessionProperty(VTSessionRef session, CFStringRef key, bool value) {
 }
 
 // Convenience function for setting a VT property.
-void SetVTSessionProperty(VTSessionRef session,
+void SetVTSessionProperty(CompressionSessionRef session,
                           CFStringRef key,
                           CFStringRef value) {
-  OSStatus status = VTSessionSetProperty(session, key, value);
+  OSStatus status = CompressionSessionSetProperty(session, key, value);
   if (status != noErr) {
     std::string key_string = CFStringToString(key);
     std::string val_string = CFStringToString(value);
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/components/video_codec/helpers.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/components/video_codec/helpers.h
index 0683ea79e56..0c669e8bce6 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/components/video_codec/helpers.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/components/video_codec/helpers.h
@@ -16,6 +16,8 @@
 #include <VideoToolbox/VideoToolbox.h>
 #include <string>
 
+#include "sdk/WebKit/EncoderUtilities.h"
+
 // Convenience function for creating a dictionary.
 inline CFDictionaryRef CreateCFTypeDictionary(CFTypeRef* keys,
                                               CFTypeRef* values,
@@ -29,18 +31,18 @@ inline CFDictionaryRef CreateCFTypeDictionary(CFTypeRef* keys,
 std::string CFStringToString(const CFStringRef cf_string);
 
 // Convenience function for setting a VT property.
-void SetVTSessionProperty(VTSessionRef session, CFStringRef key, int32_t value);
+void SetVTSessionProperty(CompressionSessionRef session, CFStringRef key, int32_t value);
 
 // Convenience function for setting a VT property.
-void SetVTSessionProperty(VTSessionRef session,
+void SetVTSessionProperty(CompressionSessionRef session,
                           CFStringRef key,
                           uint32_t value);
 
 // Convenience function for setting a VT property.
-void SetVTSessionProperty(VTSessionRef session, CFStringRef key, bool value);
+void SetVTSessionProperty(CompressionSessionRef session, CFStringRef key, bool value);
 
 // Convenience function for setting a VT property.
-void SetVTSessionProperty(VTSessionRef session,
+void SetVTSessionProperty(CompressionSessionRef session,
                           CFStringRef key,
                           CFStringRef value);
 
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/components/video_frame_buffer/RTCCVPixelBuffer.h b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/components/video_frame_buffer/RTCCVPixelBuffer.h
index 432a3825746..abe9dfca93b 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/components/video_frame_buffer/RTCCVPixelBuffer.h
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/components/video_frame_buffer/RTCCVPixelBuffer.h
@@ -17,6 +17,7 @@ NS_ASSUME_NONNULL_BEGIN
 
 /** RTCVideoFrameBuffer containing a CVPixelBufferRef */
 RTC_OBJC_EXPORT
+__attribute__((objc_runtime_name("WK_RTCCVPixelBuffer")))
 @interface RTCCVPixelBuffer : NSObject <RTCVideoFrameBuffer>
 
 @property(nonatomic, readonly) CVPixelBufferRef pixelBuffer;
diff --git a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/native/src/objc_video_encoder_factory.mm b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/native/src/objc_video_encoder_factory.mm
index ba7c3e96754..c4c85cc6ab9 100644
--- a/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/native/src/objc_video_encoder_factory.mm
+++ b/Source/ThirdParty/libwebrtc/Source/webrtc/sdk/objc/native/src/objc_video_encoder_factory.mm
@@ -92,6 +92,12 @@ class ObjCVideoEncoder : public VideoEncoder {
     return [encoder_ setBitrate:bitrate framerate:framerate];
   }
 
+  int32_t SetRateAllocation(const VideoBitrateAllocation& allocation, uint32_t framerate) {
+    RTCVideoBitrateAllocation *bitrateAllocation =
+      [[RTCVideoBitrateAllocation alloc] initWithNativeVideoBitrateAllocation:&allocation];
+    return [encoder_ setRateAllocation: bitrateAllocation framerate:framerate];
+  }
+
   bool SupportsNativeHandle() const { return true; }
 
   VideoEncoder::ScalingSettings GetScalingSettings() const {
-- 
2.17.1 (Apple Git-112)

