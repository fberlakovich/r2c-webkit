diff --git a/include/EGL/eglplatform.h b/include/EGL/eglplatform.h
index 543f8e5cb..9203604a3 100644
--- a/include/EGL/eglplatform.h
+++ b/include/EGL/eglplatform.h
@@ -110,7 +110,7 @@ typedef void*                           EGLNativeDisplayType;
 typedef struct egl_native_pixmap_t*     EGLNativePixmapType;
 typedef struct ANativeWindow*           EGLNativeWindowType;
 
-#elif defined(USE_OZONE)
+#elif defined(USE_OZONE) || defined(USE_WPE)
 
 typedef intptr_t EGLNativeDisplayType;
 typedef intptr_t EGLNativePixmapType;
diff --git a/include/GLSLANG/ShaderLang.h b/include/GLSLANG/ShaderLang.h
index c804715d2..a7cee1d46 100644
--- a/include/GLSLANG/ShaderLang.h
+++ b/include/GLSLANG/ShaderLang.h
@@ -8,7 +8,7 @@
 
 #include <stddef.h>
 
-#include "KHR/khrplatform.h"
+#include "khrplatform.h"
 
 #include <array>
 #include <map>
diff --git a/src/common/PoolAlloc.cpp b/src/common/PoolAlloc.cpp
index b6e3702f8..20645c5e3 100644
--- a/src/common/PoolAlloc.cpp
+++ b/src/common/PoolAlloc.cpp
@@ -55,7 +55,7 @@ PoolAllocator::PoolAllocator(int growthIncrement, int allocationAlignment)
         mAlignment &= ~(minAlign - 1);
         if (mAlignment < minAlign)
             mAlignment = minAlign;
-        mAlignment     = gl::ceilPow2(mAlignment);
+        mAlignment     = gl::ceilPow2(static_cast<unsigned int>(mAlignment));
         mAlignmentMask = mAlignment - 1;
 
 #if !defined(ANGLE_DISABLE_POOL_ALLOC)
@@ -331,4 +331,4 @@ void Allocation::checkAllocList() const
         alloc->check();
 }
 
-}  // namespace angle
\ No newline at end of file
+}  // namespace angle
diff --git a/src/common/mathutil.h b/src/common/mathutil.h
index edf63dd15..6573dd589 100644
--- a/src/common/mathutil.h
+++ b/src/common/mathutil.h
@@ -967,7 +967,7 @@ inline uint32_t BitfieldReverse(uint32_t value)
 }
 
 // Count the 1 bits.
-#if defined(_M_IX86) || defined(_M_X64)
+#if defined(_MSC_VER) && (defined(_M_IX86) || defined(_M_X64))
 #    define ANGLE_HAS_BITCOUNT_32
 inline int BitCount(uint32_t bits)
 {
diff --git a/src/compiler/preprocessor/ExpressionParser.cpp b/src/compiler/preprocessor/ExpressionParser.cpp
index 461c2145d..5da6a22d6 100644
--- a/src/compiler/preprocessor/ExpressionParser.cpp
+++ b/src/compiler/preprocessor/ExpressionParser.cpp
@@ -1,5 +1,7 @@
 /* A Bison parser, made by GNU Bison 3.0.4.  */
 
+/* Apple Note: For the avoidance of doubt, Apple elects to distribute this file under the terms of the BSD license. */
+
 /* Bison implementation for Yacc-like parsers in C
 
    Copyright (C) 1984, 1989-1990, 2000-2015 Free Software Foundation, Inc.
diff --git a/src/compiler/translator/ShaderVars.cpp b/src/compiler/translator/ShaderVars.cpp
index 202ed2111..2c2592ffb 100644
--- a/src/compiler/translator/ShaderVars.cpp
+++ b/src/compiler/translator/ShaderVars.cpp
@@ -112,7 +112,7 @@ unsigned int ShaderVariable::getInnerArraySizeProduct() const
     unsigned int arraySizeProduct = 1u;
     for (size_t index = 1; index < arraySizes.size(); ++index)
     {
-        arraySizeProduct *= getNestedArraySize(index);
+        arraySizeProduct *= getNestedArraySize(static_cast<unsigned int>(index));
     }
     return arraySizeProduct;
 }
diff --git a/src/compiler/translator/TranslatorHLSL.h b/src/compiler/translator/TranslatorHLSL.h
index bb8b7f285..1a9f6167e 100644
--- a/src/compiler/translator/TranslatorHLSL.h
+++ b/src/compiler/translator/TranslatorHLSL.h
@@ -16,7 +16,9 @@ class TranslatorHLSL : public TCompiler
 {
   public:
     TranslatorHLSL(sh::GLenum type, ShShaderSpec spec, ShShaderOutput output);
+#ifdef ANGLE_ENABLE_HLSL
     TranslatorHLSL *getAsTranslatorHLSL() override { return this; }
+#endif
 
     bool hasShaderStorageBlock(const std::string &interfaceBlockName) const;
     unsigned int getShaderStorageBlockRegister(const std::string &interfaceBlockName) const;
diff --git a/src/compiler/translator/TranslatorVulkan.cpp b/src/compiler/translator/TranslatorVulkan.cpp
index 19b6847e4..1c4ea950c 100644
--- a/src/compiler/translator/TranslatorVulkan.cpp
+++ b/src/compiler/translator/TranslatorVulkan.cpp
@@ -195,7 +195,7 @@ TIntermBinary *CreateDriverUniformRef(const TVariable *driverUniforms, const cha
 
     TIntermSymbol *angleUniformsRef = new TIntermSymbol(driverUniforms);
     TConstantUnion *uniformIndex    = new TConstantUnion;
-    uniformIndex->setIConst(fieldIndex);
+    uniformIndex->setIConst(static_cast<int>(fieldIndex));
     TIntermConstantUnion *indexRef =
         new TIntermConstantUnion(uniformIndex, *StaticType::GetBasic<EbtInt>());
     return new TIntermBinary(EOpIndexDirectInterfaceBlock, angleUniformsRef, indexRef);
diff --git a/src/compiler/translator/blocklayout.cpp b/src/compiler/translator/blocklayout.cpp
index 7d0609ec8..898be505f 100644
--- a/src/compiler/translator/blocklayout.cpp
+++ b/src/compiler/translator/blocklayout.cpp
@@ -258,18 +258,18 @@ void Std140BlockEncoder::getBlockLayoutInfo(GLenum type,
     if (gl::IsMatrixType(type))
     {
         baseAlignment = getTypeBaseAlignment(type, isRowMajorMatrix);
-        matrixStride  = getTypeBaseAlignment(type, isRowMajorMatrix);
+        matrixStride  = static_cast<int>(getTypeBaseAlignment(type, isRowMajorMatrix));
 
         if (!arraySizes.empty())
         {
             const int numRegisters = gl::MatrixRegisterCount(type, isRowMajorMatrix);
-            arrayStride            = getTypeBaseAlignment(type, isRowMajorMatrix) * numRegisters;
+            arrayStride            = static_cast<int>(getTypeBaseAlignment(type, isRowMajorMatrix) * numRegisters);
         }
     }
     else if (!arraySizes.empty())
     {
-        baseAlignment = getTypeBaseAlignment(type, false);
-        arrayStride   = getTypeBaseAlignment(type, false);
+        baseAlignment = static_cast<int>(getTypeBaseAlignment(type, false));
+        arrayStride   = static_cast<int>(getTypeBaseAlignment(type, false));
     }
     else
     {
diff --git a/src/compiler/translator/glslang_tab.cpp b/src/compiler/translator/glslang_tab.cpp
index a60203b85..fabad4f96 100644
--- a/src/compiler/translator/glslang_tab.cpp
+++ b/src/compiler/translator/glslang_tab.cpp
@@ -1,5 +1,7 @@
 /* A Bison parser, made by GNU Bison 3.0.4.  */
 
+/* Apple Note: For the avoidance of doubt, Apple elects to distribute this file under the terms of the BSD license. */
+
 /* Bison implementation for Yacc-like parsers in C
 
    Copyright (C) 1984, 1989-1990, 2000-2015 Free Software Foundation, Inc.
@@ -5198,4 +5200,4 @@ yyreturn:
 int glslang_parse(TParseContext* context) {
     return yyparse(context, context->getScanner());
 }
- 
\ No newline at end of file
+ 
diff --git a/src/compiler/translator/glslang_tab.h b/src/compiler/translator/glslang_tab.h
index e05076fcb..19be0f89d 100644
--- a/src/compiler/translator/glslang_tab.h
+++ b/src/compiler/translator/glslang_tab.h
@@ -1,5 +1,7 @@
 /* A Bison parser, made by GNU Bison 3.0.4.  */
 
+/* Apple Note: For the avoidance of doubt, Apple elects to distribute this file under the terms of the BSD license. */
+
 /* Bison interface for Yacc-like parsers in C
 
    Copyright (C) 1984, 1989-1990, 2000-2015 Free Software Foundation, Inc.
diff --git a/src/libANGLE/Image.cpp b/src/libANGLE/Image.cpp
index d94d311a9..3c077c365 100644
--- a/src/libANGLE/Image.cpp
+++ b/src/libANGLE/Image.cpp
@@ -162,7 +162,7 @@ gl::Format ExternalImageSibling::getAttachmentFormat(GLenum binding,
 
 GLsizei ExternalImageSibling::getAttachmentSamples(const gl::ImageIndex &imageIndex) const
 {
-    return mImplementation->getSamples();
+    return static_cast<GLsizei>(mImplementation->getSamples());
 }
 
 bool ExternalImageSibling::isRenderable(const gl::Context *context,
diff --git a/src/libANGLE/MemoryProgramCache.cpp b/src/libANGLE/MemoryProgramCache.cpp
index 9c549220a..0fc080521 100644
--- a/src/libANGLE/MemoryProgramCache.cpp
+++ b/src/libANGLE/MemoryProgramCache.cpp
@@ -134,7 +134,7 @@ angle::Result MemoryProgramCache::getProgram(const Context *context,
     if (get(context, *hashOut, &binaryProgram))
     {
         angle::Result result = program->loadBinary(context, GL_PROGRAM_BINARY_ANGLE,
-                                                   binaryProgram.data(), binaryProgram.size());
+                                                   binaryProgram.data(), static_cast<int>(binaryProgram.size()));
         ANGLE_HISTOGRAM_BOOLEAN("GPU.ANGLE.ProgramCache.LoadBinarySuccess",
                                 result == angle::Result::Continue);
         ANGLE_TRY(result);
diff --git a/src/libANGLE/Platform.cpp b/src/libANGLE/Platform.cpp
index 6cbbd1e80..e987ff0eb 100644
--- a/src/libANGLE/Platform.cpp
+++ b/src/libANGLE/Platform.cpp
@@ -15,12 +15,17 @@
 namespace
 {
 // TODO(jmadill): Make methods owned by egl::Display.
-angle::PlatformMethods g_platformMethods;
+angle::PlatformMethods& g_platformMethods()
+{
+    static angle::PlatformMethods platformMethods;
+    return platformMethods;
+}
+
 }  // anonymous namespace
 
 angle::PlatformMethods *ANGLEPlatformCurrent()
 {
-    return &g_platformMethods;
+    return &g_platformMethods();
 }
 
 bool ANGLE_APIENTRY ANGLEGetDisplayPlatform(angle::EGLDisplayType display,
@@ -53,13 +58,13 @@ bool ANGLE_APIENTRY ANGLEGetDisplayPlatform(angle::EGLDisplayType display,
     }
 
     // TODO(jmadill): Store platform methods in display.
-    g_platformMethods.context = context;
-    *platformMethodsOut       = &g_platformMethods;
+    g_platformMethods().context = context;
+    *platformMethodsOut       = &g_platformMethods();
     return true;
 }
 
 void ANGLE_APIENTRY ANGLEResetDisplayPlatform(angle::EGLDisplayType display)
 {
     // TODO(jmadill): Store platform methods in display.
-    g_platformMethods = angle::PlatformMethods();
+    g_platformMethods() = angle::PlatformMethods();
 }
diff --git a/src/libANGLE/State.cpp b/src/libANGLE/State.cpp
index 7223bb9de..e4ed138a7 100644
--- a/src/libANGLE/State.cpp
+++ b/src/libANGLE/State.cpp
@@ -1214,7 +1214,7 @@ void State::detachSampler(const Context *context, GLuint sampler)
     {
         if (mSamplers[i].id() == sampler)
         {
-            setSamplerBinding(context, i, nullptr);
+            setSamplerBinding(context, static_cast<GLuint>(i), nullptr);
         }
     }
 }
diff --git a/src/libANGLE/VertexArray.cpp b/src/libANGLE/VertexArray.cpp
index f14876668..56a783f8a 100644
--- a/src/libANGLE/VertexArray.cpp
+++ b/src/libANGLE/VertexArray.cpp
@@ -193,7 +193,7 @@ bool VertexArray::detachBuffer(const Context *context, GLuint bufferName)
             }
             else
             {
-                ASSERT(binding.getBoundAttributesMask() == AttributesMask(1ull << bindingIndex));
+                ASSERT(binding.getBoundAttributesMask() == AttributesMask(1u << bindingIndex));
                 setDirtyAttribBit(bindingIndex, DIRTY_ATTRIB_POINTER);
             }
 
diff --git a/src/libANGLE/renderer/gl/ProgramGL.cpp b/src/libANGLE/renderer/gl/ProgramGL.cpp
index e819ba8df..996aa7e1e 100644
--- a/src/libANGLE/renderer/gl/ProgramGL.cpp
+++ b/src/libANGLE/renderer/gl/ProgramGL.cpp
@@ -364,7 +364,7 @@ std::unique_ptr<LinkEvent> ProgramGL::link(const gl::Context *context,
                             // set either.
                             ASSERT(outputVar.index == -1);
                             mFunctions->bindFragDataLocationIndexed(
-                                mProgramID, outputLocationIndex, 0, outputVar.mappedName.c_str());
+                                mProgramID, static_cast<int>(outputLocationIndex), 0, outputVar.mappedName.c_str());
                         }
                     }
                 }
@@ -386,7 +386,7 @@ std::unique_ptr<LinkEvent> ProgramGL::link(const gl::Context *context,
                             // the index set either.
                             ASSERT(outputVar.index == -1);
                             mFunctions->bindFragDataLocationIndexed(
-                                mProgramID, outputLocationIndex, 1, outputVar.mappedName.c_str());
+                                mProgramID, static_cast<int>(outputLocationIndex), 1, outputVar.mappedName.c_str());
                         }
                     }
                 }
diff --git a/src/third_party/khronos/GL/wglext.h b/src/third_party/khronos/GL/wglext.h
index daba41091..86134ca73 100644
--- a/src/third_party/khronos/GL/wglext.h
+++ b/src/third_party/khronos/GL/wglext.h
@@ -33,7 +33,7 @@ extern "C" {
 ** used to make the header, and the header can be found at
 **   http://www.opengl.org/registry/
 **
-** Khronos $Revision: 27684 $ on $Date: 2014-08-11 01:21:35 -0700 (Mon, 11 Aug 2014) $
+** Khronos $Revision: 225340 $ on $Date: 2017-11-30 12:39:54 -0800 (Thu, 30 Nov 2017) $
 */
 
 #if defined(_WIN32) && !defined(APIENTRY) && !defined(__CYGWIN__) && !defined(__SCITECH_SNAP__)
