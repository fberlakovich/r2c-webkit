<!DOCTYPE html>
<html>
<head>
<title>In-Browser Tests for Performance Dashboard</title>
<link rel="stylesheet" href="https://cdn.rawgit.com/mochajs/mocha/2.2.5/mocha.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.2.5/mocha.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/expect.js/0.2.0/expect.min.js"></script>
<script>

mocha.setup('bdd');

</script>
<script src="../unit-tests/resources/mock-remote-api.js"></script>
</head>
<body>
<div id="mocha"></div>
<script src="component-base-tests.js"></script>
<script src="close-button-tests.js"></script>
<script src="editable-text-tests.js"></script>
<script src="time-series-chart-tests.js"></script>
<script>

afterEach(() => {
    BrowsingContext.cleanup();
});

class BrowsingContext {

    constructor()
    {
        let iframe = document.createElement('iframe');
        document.body.appendChild(iframe);
        iframe.style.position = 'absolute';
        iframe.style.left = '0px';
        iframe.style.top = '0px';
        BrowsingContext._iframes.push(iframe);

        this.iframe = iframe;
        this.symbols = {};
        this.global = this.iframe.contentWindow;
        this.document = this.iframe.contentDocument;
    }

    importScripts(pathList, ...symbolList)
    {
        const doc = this.iframe.contentDocument;
        const global = this.iframe.contentWindow;

        pathList = pathList.map((path) => `../public/v3/${path}`);

        return Promise.all(['../unit-tests/resources/mock-remote-api.js', ...pathList].map((path) => {
            return new Promise((resolve, reject) => {
                let script = doc.createElement('script');
                script.addEventListener('load', resolve);
                script.addEventListener('error', reject);
                script.src = path;
                script.async = false;
                doc.body.appendChild(script);
            });
        })).then(() => {
            const script = doc.createElement('script');
            script.textContent = `window.importedSymbols = [${symbolList.join(', ')}];`;
            global.RemoteAPI = global.MockRemoteAPI;
            doc.body.appendChild(script);

            const importedSymbols = global.importedSymbols;
            for (let i = 0; i < symbolList.length; i++)
                this.symbols[symbolList[i]] = importedSymbols[i];

            return symbolList.length == 1 ? importedSymbols[0] : importedSymbols;
        });
    }

    importScript(path, ...symbols)
    {
        return this.importScripts([path], ...symbols);
    }

    static cleanup()
    {
        BrowsingContext._iframes.forEach((iframe) => { iframe.remove(); });
        BrowsingContext._iframes = [];
    }
}
BrowsingContext._iframes = [];

function waitForComponentsToRender(context)
{
    if (!context._dummyComponent) {
        const ComponentBase = context.symbols.ComponentBase;
        context._dummyComponent = class SomeComponent extends ComponentBase {
            constructor(resolve)
            {
                super();
                this._resolve = resolve;
            }
            render() { setTimeout(this._resolve, 0); }
        }
        ComponentBase.defineElement('dummy-component', context._dummyComponent);
    }
    return new Promise((resolve) => {
        const instance = new context._dummyComponent(resolve);
        context.document.body.appendChild(instance.element());
        setTimeout(() => {
            instance.enqueueToRender();
        }, 0);
    });
}

function wait(milliseconds)
{
    return new Promise((resolve) => {
        setTimeout(resolve, milliseconds);
    });
}

function canvasImageData(canvas)
{
    return canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height);
}

function canvasRefTest(canvas1, canvas2, shouldMatch)
{
    expect(canvas1.offsetWidth).to.be(canvas2.offsetWidth);
    expect(canvas2.offsetHeight).to.be(canvas2.offsetHeight);
    const data1 = canvasImageData(canvas1).data;
    const data2 = canvasImageData(canvas2).data;
    expect(data1.length).to.be.a('number');
    expect(data1.length).to.be(data2.length);

    let match = true;
    for (let i = 0; i < data1.length; i++) {
        if (data1[i] != data2[i]) {
            match = false;
            break;
        }
    }

    if (match == shouldMatch)
        return;

    [canvas1, canvas2].forEach((canvas) => {
        let image = document.createElement('img');
        image.src = canvas.toDataURL();
        image.style.display = 'block';
        document.body.appendChild(image);
    });

    throw new Error(shouldMatch ? 'Canvas contents were different' : 'Canvas contents were identical');
}

const CanvasTest = {
    fillCanvasBeforeRedrawCheck(canvas)
    {
        const canvasContext = canvas.getContext('2d');
        canvasContext.fillStyle = 'white';
        canvasContext.fillRect(0, 0, canvas.width, canvas.height);
    },

    hasCanvasBeenRedrawn(canvas)
    {
        return canvasImageData(canvas).data.some((value) => value != 255);
    },

    canvasImageData(canvas) { return canvasImageData(canvas); },
    expectCanvasesMatch(canvas1, canvas2) { return canvasRefTest(canvas1, canvas2, true); },
    expectCanvasesMismatch(canvas1, canvas2) { return canvasRefTest(canvas1, canvas2, false); },
}

mocha.checkLeaks();
mocha.globals(['expect', 'BrowsingContext', 'CanvasTest', 'wait', 'waitForComponentsToRender']);
mocha.run();

</script>
</body>
</html>
